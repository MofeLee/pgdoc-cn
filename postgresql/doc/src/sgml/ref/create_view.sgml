<!--
doc/src/sgml/ref/create_view.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEVIEW">
 <refmeta>
  <refentrytitle>CREATE VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE VIEW</refname>
  <!--
  <refpurpose>define a new view</refpurpose>
  -->
  <refpurpose>定义一个新视图</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createview">
  <primary>CREATE VIEW</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <replaceable class="PARAMETER">name</replaceable> [ ( <replaceable class="PARAMETER">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="PARAMETER">view_option_name</replaceable> [= <replaceable class="PARAMETER">view_option_value</replaceable>] [, ... ] ) ]
    AS <replaceable class="PARAMETER">query</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>CREATE VIEW</command> defines a view of a query.  The view
   is not physically materialized. Instead, the query is run every time
   the view is referenced in a query.
  </para>
-->
<para>
<command>CREATE VIEW</command>定义一个查询的视图。
这个视图不是物理上实际存在的，并且在该视图每次被引用的时候都会运行一次查询。
</para>

  <!--
<para>
   <command>CREATE OR REPLACE VIEW</command> is similar, but if a view
   of the same name already exists, it is replaced.  The new query must
   generate the same columns that were generated by the existing view query
   (that is, the same column names in the same order and with the same data
   types), but it may add additional columns to the end of the list.  The
   calculations giving rise to the output columns may be completely different.
  </para>
-->
<para>
<command>CREATE OR REPLACE VIEW</command>是类似的，不过如果一个同名的视图已经存在，
那么将替换它。新查询必须生成与现有视图查询生成的字段相同的字段（也就是，
相同的字段名字，相同的顺序和相同的数据类型），但是可能添加额外的字段到列表的结尾。
该计算导致输出字段可能完全不同。
</para>

  <!--
<para>
   If a schema name is given (for example, <literal>CREATE VIEW
   myschema.myview ...</>) then the view is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   views exist in a special schema, so a schema name cannot be given
   when creating a temporary view. The name of the view must be
   distinct from the name of any other view, table, sequence, index or foreign table
   in the same schema.
  </para>
-->
<para>
如果给出了一个模式名(比如<literal>CREATE VIEW myschema.myview ...</>)，
那么该视图将在指定的模式中创建，否则将在当前模式中创建。
临时视图存在于一个特殊的模式里，所以创建临时视图的时候，不能给出模式名。
新视图名字必需和同一模式中任何其它视图、表、序列、索引或外部表的名字不同。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>
   <varlistentry>
    <!--
<term><literal>TEMPORARY</> or <literal>TEMP</></term>
-->
<term><literal>TEMPORARY</> 或 <literal>TEMP</></term>
    <listitem>
     <!--
<para>
      If specified, the view is created as a temporary view.
      Temporary views are automatically dropped at the end of the
      current session.  Existing
      permanent relations with the same name are not visible to the
      current session while the temporary view exists, unless they are
      referenced with schema-qualified names.
     </para>
-->
<para>
如果声明了这个子句，那么视图就以临时视图的方式创建。
临时视图在当前会话结束的时候将被自动删除。只要存在临时视图，
已有的同名永久关系表将对当前会话不可见，除非用带模式修饰的名字引用它们。
</para>

     <!--
<para>
      If any of the tables referenced by the view are temporary,
      the view is created as a temporary view (whether
      <literal>TEMPORARY</literal> is specified or not).
     </para>
-->
<para>
如果视图引用的任何基础表是临时的，那么视图将被创建为临时的
(不管是否声明了<literal>TEMPORARY</literal>)。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RECURSIVE</></term>
    <listitem>
     <!--
<para>
      Creates a recursive view.  The syntax
<synopsis>
CREATE RECURSIVE VIEW <replaceable>name</> (<replaceable>columns</>) AS SELECT <replaceable>...</>;
</synopsis>
      is equivalent to
<synopsis>
CREATE VIEW <replaceable>name</> AS WITH RECURSIVE <replaceable>name</> (<replaceable>columns</>) AS (SELECT <replaceable>...</>) SELECT <replaceable>columns</> FROM <replaceable>name</>;
</synopsis>
      A view column list must be specified for a recursive view.
     </para>
-->
<para>
创建一个递归的视图。语法
<synopsis>
CREATE RECURSIVE VIEW <replaceable>name</> (<replaceable>columns</>) AS SELECT <replaceable>...</>;
</synopsis>
等同于
<synopsis>
CREATE VIEW <replaceable>name</> AS WITH RECURSIVE <replaceable>name</> (<replaceable>columns</>) AS (SELECT <replaceable>...</>) SELECT <replaceable>columns</> FROM <replaceable>name</>;
</synopsis>
必须为一个递归的视图指定一个视图字段列表。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (optionally schema-qualified) of a view to be created.
     </para>
-->
<para>
所要创建的视图名称(可以有模式修饰)。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
    <listitem>
     <!--
<para>
      An optional list of names to be used for columns of the view.
      If not given, the column names are deduced from the query.
     </para>
-->
<para>
一个可选的名字列表，用作视图的字段名。如果没有给出，字段名取自查询。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="PARAMETER">view_option_name</replaceable> [= <replaceable class="PARAMETER">view_option_value</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <!--
<para>
      This clause specifies optional parameters for a view; currently, the
      only supported parameter name is <literal>security_barrier</literal>,
      which should be enabled when a view is intended to provide row-level
      security.  See <xref linkend="rules-privileges"> for full details.
     </para>
-->
<para>
该子句为视图指定选项参数；目前，唯一支持的参数名是<literal>security_barrier</literal>，
当视图打算提供行级安全时，应该启用该参数。参阅<xref linkend="rules-privileges">
获取全部细节。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
     <!--
<para>
      A <xref linkend="sql-select"> or
      <xref linkend="sql-values"> command
      which will provide the columns and rows of the view.
     </para>
-->
<para>
一个将为视图提供行和列的<xref linkend="sql-select">
或<xref linkend="sql-values">语句。
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    Use the <xref linkend="sql-dropview">
    statement to drop views.
   </para>
-->
<para>
使用<xref linkend="sql-dropview">语句删除视图。
</para>

   <!--
<para>
    Be careful that the names and types of the view's columns will be
    assigned the way you want.  For example:
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    is bad form in two ways: the column name defaults to <literal>?column?</>,
    and the column data type defaults to <type>unknown</>.  If you want a
    string literal in a view's result, use something like:
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>
-->
<para>
请注意视图字段的名字和类型不一定是你们期望的那样。比如，
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
在两个方面很糟糕：字段名缺省是<literal>?column?</>
并且字段的数据类型缺省是<type>unknown</>。
如果你想视图的结果是一个字符串文本，那么请像下面这样使用：
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
</para>

   <!--
<para>
    Access to tables referenced in the view is determined by permissions of
    the view owner.  In some cases, this can be used to provide secure but
    restricted access to the underlying tables.  However, not all views are
    secure against tampering; see <xref linkend="rules-privileges"> for
    details.  Functions called in the view are treated the same as if they had
    been called directly from the query using the view.  Therefore the user of
    a view must have permissions to call all functions used by the view.
   </para>
-->
<para>
对视图引用的表的访问的权限由视图的所有者决定。在一些情况下，
这可用于提供安全但是限制访问底层表。不过，不是所有视图对于篡改都是安全的；
参阅<xref linkend="rules-privileges">获取细节。
在视图里被调用的函数，被当作直接从使用视图的查询里调用它们看待。因此，
视图的用户必须有调用视图使用的所有函数的权限。
</para>

   <!--
<para>
    When <command>CREATE OR REPLACE VIEW</> is used on an
    existing view, only the view's defining SELECT rule is changed.
    Other view properties, including ownership, permissions, and non-SELECT
    rules, remain unchanged.  You must own the view
    to replace it (this includes being a member of the owning role).
   </para>
-->
<para>
当<command>CREATE OR REPLACE VIEW</>用在一个现有的视图上时，
只改变了视图定义的SELECT规则。其他视图属性，包括所有权、权限和非SELECT规则，
保持不变。要替换视图，你必须拥有该视图（包括成为拥有者角色的一员）。
</para>

  <refsect2 id="SQL-CREATEVIEW-updatable-views">
   <!--
   <title id="SQL-CREATEVIEW-updatable-views-title">Updatable Views</title>
   -->
   <title id="SQL-CREATEVIEW-updatable-views-title">可更新的视图</title>

   <indexterm zone="sql-createview-updatable-views">
    <!--
<primary>updatable views</primary>
-->
<primary>可更新的视图</primary>
   </indexterm>

   
<para>
<!-- 
    Simple views are automatically updatable: the system will allow
    <command>INSERT</>, <command>UPDATE</> and <command>DELETE</> statements
    to be used on the view in the same way as on a regular table.  A view is
    automatically updatable if it satisfies all of the following conditions:
 -->
简单的视图是自动可更新的：系统允许<command>INSERT</>、<command>UPDATE</>
和<command>DELETE</>语句，和在常规表上一样的方式，被用在视图上。
如果视图满足所有下列的条件，那么就是自动可更新的：
    <itemizedlist>
     <listitem>
<!--
      <para>
       The view must have exactly one entry in its <literal>FROM</> list,
       which must be a table or another updatable view.
      </para>
-->
<para>
视图在它的<literal>FROM</>列表中必须只有一个条目，
该条目必须是一个表或其他可更新视图。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The view definition must not contain <literal>WITH</>,
       <literal>DISTINCT</>, <literal>GROUP BY</>, <literal>HAVING</>,
       <literal>LIMIT</>, or <literal>OFFSET</> clauses at the top level.
      </para>
-->
<para>
视图定义必须没有在顶级包含<literal>WITH</>、<literal>DISTINCT</>、<literal>GROUP BY</>、
<literal>HAVING</>、<literal>LIMIT</>或<literal>OFFSET</>子句。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The view definition must not contain set operations (<literal>UNION</>,
       <literal>INTERSECT</> or <literal>EXCEPT</>) at the top level.
      </para>
-->
<para>
视图定义必须没有在顶级包含集合运算（<literal>UNION</>、<literal>INTERSECT</>
或<literal>EXCEPT</>）。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       All columns in the view's select list must be simple references to
       columns of the underlying relation.  They cannot be expressions,
       literals or functions.  System columns cannot be referenced, either.
      </para>
-->
<para>
视图的选择列表中的所有字段必须简单的引用底层关系的字段。
它们不能是表达式、字面值或函数。也不能引用系统字段。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       No column of the underlying relation can appear more than once in
       the view's select list.
      </para>
-->
<para>
在视图的选择列表中，底层关系的字段出现不能超过一次。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The view must not have the <literal>security_barrier</> property.
      </para>
-->
<para>
视图必须没有<literal>security_barrier</>属性。
</para>
     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    If the view is automatically updatable the system will convert any
    <command>INSERT</>, <command>UPDATE</> or <command>DELETE</> statement
    on the view into the corresponding statement on the underlying base
    relation.
   </para>
-->
<para>
如果视图是自动可更新的，那么系统将转换视图上的任意<command>INSERT</>、
<command>UPDATE</>或<command>DELETE</>语句为相应的底层基本关系上的语句。
</para>

   <!--
<para>
    If an automatically updatable view contains a <literal>WHERE</>
    condition, the condition restricts which rows of the base relation are
    available to be modified by <command>UPDATE</> and <command>DELETE</>
    statements on the view.  However, an <command>UPDATE</> is allowed to
    change a row so that it no longer satisfies the <literal>WHERE</>
    condition, and thus is no longer visible through the view.  Similarly,
    an <command>INSERT</> command can potentially insert base-relation rows
    that do not satisfy the <literal>WHERE</> condition and thus are not
    visible through the view.
   </para>
-->
<para>
如果一个自动可更新的视图包含一个<literal>WHERE</>条件，
那么该条件约束基本关系的哪些行可以被视图上的<command>UPDATE</>
和<command>DELETE</>语句修改。不过，允许<command>UPDATE</>
更改一个行，使得它不再满足<literal>WHERE</>条件，并且因此不再通过视图可见。
相似的，<command>INSERT</>命令也可以插入不满足<literal>WHERE</>
条件的基本关系行，并且因此对这个视图不可见。
</para>

   <!--
<para>
    A more complex view that does not satisfy all these conditions is
    read-only by default: the system will not allow an insert, update, or
    delete on the view.  You can get the effect of an updatable view by
    creating <literal>INSTEAD OF</> triggers on the view, which must
    convert attempted inserts, etc. on the view into appropriate actions
    on other tables.  For more information see <xref
    linkend="sql-createtrigger">.  Another possibility is to create rules
    (see <xref linkend="sql-createrule">), but in practice triggers are
    easier to understand and use correctly.
   </para>
-->
<para>
不满足所有这些条件的更复杂的视图缺省是只读的：系统将不允许在该视图上插入、
更新或删除。可以通过在该视图上创建<literal>INSTEAD OF</>触发器获得可更新视图的效果，
该触发器必须转换在该视图上的尝试插入等为其他表上的适当动作。更多信息请参见
<xref linkend="sql-createtrigger">。还有一种可能性是创建规则
（参阅<xref linkend="sql-createrule">），但是实际上触发器更容易理解和正确使用。
</para>

   <!--
<para>
    Note that the user performing the insert, update or delete on the view
    must have the corresponding insert, update or delete privilege on the
    view.  In addition the view's owner must have the relevant privileges on
    the underlying base relations, but the user performing the update does
    not need any permissions on the underlying base relations (see
    <xref linkend="rules-privileges">).
   </para>
-->
<para>
请注意，用户在视图上执行插入、更新或删除必须在该视图上有相应的插入、
更新或删除的权限。此外，视图的所有者必须在底层基础关系上有相关的权限，
但是执行更新的用户不需要在底层基础关系上的任何权限
（参阅<xref linkend="rules-privileges">）。
</para>
  </refsect2>
 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   Create a view consisting of all comedy films:

<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
   This will create a view containing the columns that are in the
   <literal>film</> table at the time of view creation.  Though
   <literal>*</> was used to create the view, columns added later to
   the table will not be part of the view.
  </para>
-->
<para>
创建一个由所有喜剧电影组成的视图：
<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
这将创建一个，包含了在视图创建的时候<literal>film</>表中所有字段，的视图。
尽管用<literal>*</>创建了该视图，但是后来添加到表中的字段将不会是视图的一部分。
</para>

  <!--
<para>
   Create a recursive view consisting of the numbers from 1 to 100:
<programlisting>
CREATE RECURSIVE VIEW nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n < 100;
</programlisting></para>
-->
<para>
创建一个由数字1到100组成的递归的视图：
<programlisting>
CREATE RECURSIVE VIEW nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n < 100;
</programlisting>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

  <!--
<para>
   The SQL standard specifies some additional capabilities for the
   <command>CREATE VIEW</command> statement:
<synopsis>
CREATE VIEW <replaceable class="parameter">name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    AS <replaceable class="PARAMETER">query</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
  </para>
-->
<para>
SQL 标准为<command>CREATE VIEW</command>声明了一些附加的功能：
<synopsis>
CREATE VIEW <replaceable class="parameter">name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    AS <replaceable class="PARAMETER">query</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
</para>


<para>
   <!--
   The optional clauses for the full SQL command are:
   -->
   完整的 SQL 命令可选的子句是：

   <variablelist>
     <varlistentry>
      <term><literal>CHECK OPTION</literal></term>
      <listitem>
  <!--
  <para>
        This option controls the behavior of automatically updatable views.
        When given, <command>INSERT</> and <command>UPDATE</> commands on
        the view will be checked to ensure new rows satisfy the
        view-defining condition (that is, the new rows would be visible
        through the view). If they do not, the update will be rejected.
        Without <literal>CHECK OPTION</literal>, <command>INSERT</> and
        <command>UPDATE</> commands on the view are allowed to create rows
        that are not visible through the view.  (The latter behavior is the
        only one currently provided by <productname>PostgreSQL</>.)
       </para>
-->
<para>
这个选项控制自动可更新视图的行为。给出时，对视图的<command>INSERT</>
和<command>UPDATE</>都要检查以确保新行满足视图定义的条件（也就是说，
新行应该可以通过视图看到）。如果没有通过检查，更新将被拒绝。
如果没有<literal>CHECK OPTION</literal>，将允许对视图的<command>INSERT</>
和<command>UPDATE</>命令创建通过该视图不可见的行。
（后者的行为当前只有<productname>PostgreSQL</>提供。）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LOCAL</literal></term>
      <listitem>
       <!--
<para>
        Check for integrity on this view.
       </para>
-->
<para>
对这个视图进行完整性检查。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADED</literal></term>
      <listitem>
       <!--
<para>
        Check for integrity on this view and on any dependent
        view. <literal>CASCADED</> is assumed if neither
        <literal>CASCADED</> nor <literal>LOCAL</> is specified.
       </para>
-->
<para>
对此视图和任何依赖的视图进行完整性检查。在既没有声明<literal>CASCADED</>
也没有声明<literal>LOCAL</>时，假设为<literal>CASCADED</>。
</para>
      </listitem>
     </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   <command>CREATE OR REPLACE VIEW</command> is a
   <productname>PostgreSQL</productname> language extension.
   So is the concept of a temporary view.
   The <literal>WITH</> clause is an extension as well.
  </para>
-->
<para>
<command>CREATE OR REPLACE VIEW</command>是<productname>PostgreSQL</productname>
的扩展。临时视图的概念也是扩展。<literal>WITH</>子句也是一个扩展。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>See Also</title>
-->
<title>又见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterview"></member>
   <member><xref linkend="sql-dropview"></member>
   <member><xref linkend="sql-creatematerializedview"></member>
  </simplelist>
 </refsect1>
</refentry>
