<!-- doc/src/sgml/syntax.sgml -->

<chapter id="sql-syntax">
 <!-- <title>SQL Syntax</title> -->
<title>SQL语法</title>
 <indexterm zone="sql-syntax">
  <primary>syntax</primary>
  <secondary>SQL</secondary>
 </indexterm>

 <!-- 
 <para>
  This chapter describes the syntax of SQL.  It forms the foundation
  for understanding the following chapters which will go into detail
  about how SQL commands are applied to define and modify data.
 </para> 
 -->
 <para>
本章描述 SQL 的语法。这些内容是理解随后各章的基础，
那些章里面将详细介绍 SQL 命令如何用于定义和修改数据。
 </para>
 <!-- 
 <para>
  We also advise users who are already familiar with SQL to read this
  chapter carefully because it contains several rules and concepts that
  are implemented inconsistently among SQL databases or that are
  specific to <productname>PostgreSQL</productname>.
 </para> 
 -->
<para>
我们也建议那些已经很熟悉 SQL 的用户仔细阅读本章，因为有一些规则和概念在 SQL
数据库之间并不一致，或者是有些东西是<productname>PostgreSQL</productname>特有的。 
</para> 
 <sect1 id="sql-syntax-lexical">
  <!-- <title>Lexical Structure</title> -->
<title>词法结构</title>
  <indexterm>
   <primary>token</primary>
  </indexterm>

  <!-- 
  <para>
   SQL input consists of a sequence of
   <firstterm>commands</firstterm>.  A command is composed of a
   sequence of <firstterm>tokens</firstterm>, terminated by a
   semicolon (<quote>;</quote>).  The end of the input stream also
   terminates a command.  Which tokens are valid depends on the syntax
   of the particular command.
  </para> 
  -->
<para>
SQL 输入由一系列<firstterm>命令</firstterm>组成。一条命令由一系列<firstterm>记号</firstterm>
构成，用一个分号(<quote>;</quote>)结尾。输入流的终止也结束一条命令。
哪些记号是合法的取决于特定命令的语法。  
</para>  
  <!-- 
  <para>
   A token can be a <firstterm>key word</firstterm>, an
   <firstterm>identifier</firstterm>, a <firstterm>quoted
   identifier</firstterm>, a <firstterm>literal</firstterm> (or
   constant), or a special character symbol.  Tokens are normally
   separated by whitespace (space, tab, newline), but need not be if
   there is no ambiguity (which is generally only the case if a
   special character is adjacent to some other token type).
  </para> 
  -->
<para>
记号可以是一个<firstterm>关键字</firstterm>、<firstterm>标识符</firstterm>、
<firstterm>引号包围的标识符</firstterm>、<firstterm>文本</firstterm>(或常量)、
特殊的字符符号。记号通常由空白分隔(空格/tab/换行符)，
但如果不存在混淆的时候也可以不用(通常只是一个特殊字符与一些其它记号类型相连的时候)。
</para>
   <para>
    <!-- 
For example, the following is (syntactically) valid SQL input: 
-->
比如，下列命令是(语法上)合法的 SQL 输入：
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
    <!-- 
This is a sequence of three commands, one per line (although this
    is not required; more than one command can be on a line, and
    commands can usefully be split across lines). 
-->
这里是三条命令的序列，每条一行(尽管并不要求这么做；多条命令可以在一行里，
单条命令也可以合理地分裂成多行)。
   </para>

  <!-- 
  <para>
   Additionally, <firstterm>comments</firstterm> can occur in SQL
   input.  They are not tokens, they are effectively equivalent to
   whitespace.
  </para> 
  -->
<para>
另外，在 SQL 输入里可以有<firstterm>注释</firstterm>。它们不是记号，它们实际上等效于空白。  
</para>  
  <!-- 
  <para>
   The SQL syntax is not very consistent regarding what tokens
   identify commands and which are operands or parameters.  The first
   few tokens are generally the command name, so in the above example
   we would usually speak of a <quote>SELECT</quote>, an
   <quote>UPDATE</quote>, and an <quote>INSERT</quote> command.  But
   for instance the <command>UPDATE</command> command always requires
   a <token>SET</token> token to appear in a certain position, and
   this particular variation of <command>INSERT</command> also
   requires a <token>VALUES</token> in order to be complete.  The
   precise syntax rules for each command are described in <xref linkend="reference">.
  </para> 
  -->
<para>
如果从哪些记号标识命令、哪些是操作数或参数的角度考虑，SQL 语法并不是非常一致。
通常头几个记号是命令名字，因此上面的例子我们通常可以说是一个<quote>SELECT</quote>、
一个<quote>UPDATE</quote>、和一个<quote>INSERT</quote>命令。不过，<command>UPDATE</command>
命令总是要求一个<token>SET</token>在某个位置出现，并且这个特定的<command>INSERT</command>
还要求有一个<token>VALUES</token>才完整。每条命令的准确语法规则都在<xref linkend="reference">里描述。  
</para>   
  <sect2 id="sql-syntax-identifiers">
   <!-- <title>Identifiers and Key Words</title> -->
<title>标识符和关键字</title>
   <indexterm zone="sql-syntax-identifiers">
    <primary>identifier</primary>
    <secondary>syntax of</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>name</primary>
    <secondary>syntax of</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>key word</primary>
    <secondary>syntax of</secondary>
   </indexterm>

   <!-- 
   <para>
    Tokens such as <token>SELECT</token>, <token>UPDATE</token>, or
    <token>VALUES</token> in the example above are examples of
    <firstterm>key words</firstterm>, that is, words that have a fixed
    meaning in the SQL language.  The tokens <token>MY_TABLE</token>
    and <token>A</token> are examples of
    <firstterm>identifiers</firstterm>.  They identify names of
    tables, columns, or other database objects, depending on the
    command they are used in.  Therefore they are sometimes simply
    called <quote>names</quote>.  Key words and identifiers have the
    same lexical structure, meaning that one cannot know whether a
    token is an identifier or a key word without knowing the language.
    A complete list of key words can be found in <xref
    linkend="sql-keywords-appendix">.
   </para> 
   -->
<para>
像上面例子里的<token>SELECT</token>，<token>UPDATE</token>或<token>VALUES</token>
这样的记号都是<firstterm>关键字</firstterm>的例子，也就是那些在 SQL
语言里有固定含义的单词。记号<token>MY_TABLE</token>和<token>A</token>
是<firstterm>标识符</firstterm>的例子。根据使用它们的命令的不同，
它们标识表、字段、或者其它数据库对象的名字。因此，有时候只是简单地叫它们
<quote>名字</quote>。关键字和标识符有着同样的词法结构，
意思是我们在没有认识这种语言之前是无法区分一个记号是标识符还是名字。
你可以在<xref linkend="sql-keywords-appendix">里找到一个关键字的完整列表。
</para> 
   <!-- 
   <para>
    SQL identifiers and key words must begin with a letter
    (<literal>a</literal>-<literal>z</literal>, but also letters with
    diacritical marks and non-Latin letters) or an underscore
    (<literal>_</literal>).  Subsequent characters in an identifier or
    key word can be letters, underscores, digits
    (<literal>0</literal>-<literal>9</literal>), or dollar signs
    (<literal>$</>).  Note that dollar signs are not allowed in identifiers
    according to the letter of the SQL standard, so their use might render
    applications less portable.
    The SQL standard will not define a key word that contains
    digits or starts or ends with an underscore, so identifiers of this
    form are safe against possible conflict with future extensions of the
    standard.
   </para> 
   -->
<para>
SQL 标识符和关键字必须以一个字母(<literal>a</literal>-<literal>z</literal>
以及带变音符的字母和非拉丁字母)或下划线(<literal>_</literal>)开头，
随后的字符可以是字母、下划线、数字(<literal>0</literal>-<literal>9</literal>)、
美元符号(<literal>$</>)。需要注意的是，根据 SQL 标准，美元符号不允许出现在标识符中，
因此使用美元符号将不易移植。SQL 标准不会定义包含数字或者以下划线开头或结尾的关键字，
因此按照这种格式定义的标识符是安全的，不会和将来标准的扩展特性冲突。
</para>
   <!-- 
   <para>
    <indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
    The system uses no more than <symbol>NAMEDATALEN</symbol>-1
    bytes of an identifier; longer names can be written in
    commands, but they will be truncated.  By default,
    <symbol>NAMEDATALEN</symbol> is 64 so the maximum identifier
    length is 63 bytes. If this limit is problematic, it can be raised by
    changing the <symbol>NAMEDATALEN</symbol> constant in
    <filename>src/include/pg_config_manual.h</filename>.
   </para> 
   -->
<para>
<indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
系统使用不超过<symbol>NAMEDATALEN</symbol>-1 个字符作为标识符；
你可以在命令中写更长的名字，但它们会被截断。<symbol>NAMEDATALEN</symbol>的缺省值是 64 ，
因此标识符最大长度是 63 字节。如果觉得这个限制有问题，那么你可以在
<filename>src/include/pg_config_manual.h</filename>里修改<symbol>NAMEDATALEN</symbol>来改变它。   
</para>   
   <para>
    <indexterm>
     <primary>case sensitivity</primary>
     <secondary>of SQL commands</secondary>
    </indexterm>
    <!-- 
Key words and unquoted identifiers are case insensitive.  Therefore: 
-->
关键字和未被引号包围的标识符都是大小写无关的。因此：
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
    <!--
can equivalently be written as:
-->
也可以等效地写成：
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
    <!-- 
A convention often used is to write key words in upper
    case and names in lower case, e.g.: 
-->
一种好习惯是把关键字写成大写，而名字等用小写：
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>

   <para>
    <indexterm>
     <primary>quotation marks</primary>
     <secondary>and identifiers</secondary>
    </indexterm>
    <!-- 
There is a second kind of identifier:  the <firstterm>delimited
    identifier</firstterm> or <firstterm>quoted
    identifier</firstterm>.  It is formed by enclosing an arbitrary
    sequence of characters in double-quotes
    (<literal>"</literal>).  " font-lock mania A delimited
    identifier is always an identifier, never a key word.  So
    <literal>"select"</literal> could be used to refer to a column or
    table named <quote>select</quote>, whereas an unquoted
    <literal>select</literal> would be taken as a key word and
    would therefore provoke a parse error when used where a table or
    column name is expected.  The example can be written with quoted
    identifiers like this: 
-->
还有第二种标识符：<firstterm>分隔标识符</firstterm>或 <firstterm>引号包围的标识符</firstterm>。
它是通过在双引号(<literal>"</literal>)中包围任意字符序列形成的。
分隔标识符总是一个标识符，而不是关键字。因此，你可以用<literal>"select"</literal>
表示一个字段或者表的名字，而一个没有引号的<literal>select</literal>
将被当做一条命令的一部分，因此如果把它当做一个表名或者字段名使用的话就会产生一个分析错误。
上面的例子可以用引号包围的标识符这么写：
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>

   <!-- 
   <para>
    Quoted identifiers can contain any character, except the character
    with code zero.  (To include a double quote, write two double quotes.)
    This allows constructing table or column names that would
    otherwise not be possible, such as ones containing spaces or
    ampersands.  The length limitation still applies.
   </para> 
   -->
<para>
引号包围的标识符可以包含编码不等于零的任意字符(要包含一个双引号，可以写两个相连的双引号)。
这样我们就可以构造那些原本是不允许的表名或者字段名，比如那些包含空白或与号(&)的名字。
但长度限制依旧。
</para>
   <indexterm>
     <primary>Unicode escape</primary>
     <secondary>in identifiers</secondary>
   </indexterm>

   <para>
    <!-- 
A variant of quoted
    identifiers allows including escaped Unicode characters identified
    by their code points.  This variant starts
    with <literal>U&amp;</literal> (upper or lower case U followed by
    ampersand) immediately before the opening double quote, without
    any spaces in between, for example <literal>U&amp;"foo"</literal>.
    (Note that this creates an ambiguity with the
    operator <literal>&amp;</literal>.  Use spaces around the operator to
    avoid this problem.)  Inside the quotes, Unicode characters can be
    specified in escaped form by writing a backslash followed by the
    four-digit hexadecimal code point number or alternatively a
    backslash followed by a plus sign followed by a six-digit
    hexadecimal code point number.  For example, the
    identifier <literal>"data"</literal> could be written as 
-->
一个带引号的标识符的变形允许带有代码点标记的转义Unicode字符。
该变形以<literal>U&amp;</literal>开始（大/小写U后跟有&amp;符号）紧跟着打开的双引号，
之间没有空格，例如<literal>U&amp;"foo"</literal>。（需要注意的是，
这可能产生和操作符<literal>&amp;</literal>之间的歧义。可以在操作符周围加上空格来避免该问题。）
在引号中，通过写一个后面跟有反斜杠和四位十六进制代码点或跟有反斜杠和加号和六位十六进制代码点，
Unicode字符可以写成转义格式。 例如，<literal>"data"</literal>可以写成： 
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
    <!-- 
The following less trivial example writes the Russian
    word <quote>slon</quote> (elephant) in Cyrillic letters: 
-->
下例以西里尔字母写俄文<quote>slon</quote>（象）。 
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>

   <para>
    <!-- 
If a different escape character than backslash is desired, it can
    be specified using
    the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
    clause after the string, for example: 
-->
如果需要一个非反斜杠的不同的转义，可以通过在字符串之后使用<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
语句来进行声明，如：
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
    <!-- 
The escape character can be any single character other than a
    hexadecimal digit, the plus sign, a single quote, a double quote,
    or a whitespace character.  Note that the escape character is
    written in single quotes, not double quotes. 
-->
转义字符可以是一个十六进制数字以外的任何单个字符，加号，一个单引号，一个双引号，
或一个空白字符。需要注意的是，转义字符是写在单引号中，而不是双引号中。 
   </para>

   <!-- 
   <para>
    To include the escape character in the identifier literally, write
    it twice.
   </para> 
   -->
<para>
为了将转义字符写到标识符中，可以将它写两次。    
</para>   
   <!-- 
   <para>
    The Unicode escape syntax works only when the server encoding is
    <literal>UTF8</>.  When other server encodings are used, only code
    points in the ASCII range (up to <literal>\007F</literal>) can be
    specified.  Both the 4-digit and the 6-digit form can be used to
    specify UTF-16 surrogate pairs to compose characters with code
    points larger than U+FFFF, although the availability of the
    6-digit form technically makes this unnecessary.  (Surrogate
    pairs are not stored directly, but combined into a single
    code point that is then encoded in UTF-8.)
   </para> 
   -->
<para>
只有服务器字符集是<literal>UTF8</>时，才会完全使用Unicode转义语法。
当使用其他服务器字符集时，只有在ASCII内的（最多<literal>\007F</literal>）代码点可以被声明。
4位和6位的数字形式可以被用来将UTF-16代理对声明为大于U+FFFF的带有代码点的字符，
尽管6位数字形式技术的可用性使得这样做没有必要。（代理对不是直接存储的，
首先，它们结合成一个单一的代码点，然后再用UTF-8编码。）   
</para>   
   <!-- 
   <para>
    Quoting an identifier also makes it case-sensitive, whereas
    unquoted names are always folded to lower case.  For example, the
    identifiers <literal>FOO</literal>, <literal>foo</literal>, and
    <literal>"foo"</literal> are considered the same by
    <productname>PostgreSQL</productname>, but
    <literal>"Foo"</literal> and <literal>"FOO"</literal> are
    different from these three and each other.  (The folding of
    unquoted names to lower case in <productname>PostgreSQL</> is
    incompatible with the SQL standard, which says that unquoted names
    should be folded to upper case.  Thus, <literal>foo</literal>
    should be equivalent to <literal>"FOO"</literal> not
    <literal>"foo"</literal> according to the standard.  If you want
    to write portable applications you are advised to always quote a
    particular name or never quote it.)
   </para> 
   -->
<para>   
把一个标识符用引号包围起来同时也令它大小写相关，而没有引号包围起来的名字总是转成小写。
比如，我们认为标识符<literal>FOO</literal>，<literal>foo</literal>和<literal>"foo"</literal>
是等价的<productname>PostgreSQL</productname>名字，但<literal>"Foo"</literal>和<literal>"FOO"</literal>
与上面三个以及它们之间都是不同的。<productname>PostgreSQL</>里对未加引号的名子总是转换成小写，
这和 SQL 标准是不兼容的，SQL 标准要求未用引号包围起来的名字总是转成大写。因此根据标准，
<literal>foo</literal>等于<literal>"FOO"</literal>但不等于<literal>"foo"</literal> 。
如果你想编写可移植的程序，那么我们建议你要么就总是用引号包围某个名字，要么就从来不引。   
</para>   
  </sect2>


  <sect2 id="sql-syntax-constants">
   <!-- <title>Constants</title> -->
<title>常量</title>
   <indexterm zone="sql-syntax-constants">
    <primary>constant</primary>
   </indexterm>

   <!-- 
   <para>
    There are three kinds of <firstterm>implicitly-typed
    constants</firstterm> in <productname>PostgreSQL</productname>:
    strings, bit strings, and numbers.
    Constants can also be specified with explicit types, which can
    enable more accurate representation and more efficient handling by
    the system. These alternatives are discussed in the following
    subsections.
   </para> 
   -->
<para>
在<productname>PostgreSQL</productname>里有三种<firstterm>隐含类型的常量</firstterm>：
字符串、位串、数值。常量也可以声明为明确的类型，
这样就可以使用更准确的表现形式以及可以被系统更有效地处理。这些将在后面的小节描述。
</para> 
   <sect3 id="sql-syntax-strings">
    <!-- <title>String Constants</title> -->
<title>字符串常量</title>
    <indexterm zone="sql-syntax-strings">
     <primary>character string</primary>
     <secondary>constant</secondary>
    </indexterm>

    <para>
     <indexterm>
      <primary>quotation marks</primary>
      <secondary>escaping</secondary>
     </indexterm>
     <!-- 
 A string constant in SQL is an arbitrary sequence of characters
     bounded by single quotes (<literal>'</literal>), for example
     <literal>'This is a string'</literal>.  To include
     a single-quote character within a string constant,
     write two adjacent single quotes, e.g.,
     <literal>'Dianne''s horse'</literal>.
     Note that this is <emphasis>not</> the same as a double-quote
     character (<literal>"</>).
 --> <!-- font-lock sanity: " -->
SQL 里的一个文本常量是用单引号(<literal>'</literal>)包围的任意字符序列，
比如<literal>'This is a string'</literal> 。
在这种类型的字符串常量里嵌入单引号的标准兼容的做法是敲入两个连续的单引号，
比如<literal>'Dianne''s horse'</literal>。注意：两个连续的单引号<emphasis>不是</>双引号(<literal>"</>)。 
    </para>

    <para>
     <!-- 
 Two string constants that are only separated by whitespace
     <emphasis>with at least one newline</emphasis> are concatenated
     and effectively treated as if the string had been written as one
     constant.  For example:
 -->
两个只是通过<emphasis>至少一个换行符</emphasis>的空白分隔的字符串常量会被连接在一起，
并当做它们是写成一个常量处理。比如： 
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
    <!-- 
is equivalent to: 
-->
等效于：
<programlisting>
SELECT 'foobar';
</programlisting>
     <!-- but: -->
但：
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
     <!-- 
 is not valid syntax.  (This slightly bizarre behavior is specified
     by <acronym>SQL</acronym>; <productname>PostgreSQL</productname> is
     following the standard.) 
 -->
是非法的语法。这个怪异的行为是<acronym>SQL</acronym>声明的，<productname>PostgreSQL</productname>遵循标准。 
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
    <!-- 
<title>String Constants with C-style Escapes</title> 
-->
<title>C风格的转义字符串常量</title>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>escape string syntax</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>backslash escapes</primary>
     </indexterm>

    <!-- 
<para>
     <productname>PostgreSQL</productname> also accepts <quote>escape</>
     string constants, which are an extension to the SQL standard.
     An escape string constant is specified by writing the letter
     <literal>E</literal> (upper or lower case) just before the opening single
     quote, e.g., <literal>E'foo'</>.  (When continuing an escape string
     constant across lines, write <literal>E</> only before the first opening
     quote.)
     Within an escape string, a backslash character (<literal>\</>) begins a
     C-like <firstterm>backslash escape</> sequence, in which the combination
     of backslash and following character(s) represent a special byte
     value, as shown in <xref linkend="sql-backslash-table">.
    </para> 
-->
<para>
<productname>PostgreSQL</productname>还允许<quote>转义</>字符串中的内容，
这是一个PostgreSQL对SQL标准的扩展。转义字符串语法是通过在字符串前写字母<literal>E</literal>
(大写或者小写)的方法声明的。比如<literal>E'foo'</>。（当需要续行包含转义字符的字符串时，
仅需要在第一行的开始引号前写上<literal>E</>就可以了。）在转义字符串中，
通过一个反斜杠(<literal>\</>)开始C风格的<firstterm>反斜杠转义</>序列，在该转义中，
反斜杠与其之后字符的组合代表一个特殊的字节值，可参阅<xref linkend="sql-backslash-table">。 
</para>
     <table id="sql-backslash-table">
      <!-- 
  <title>Backslash Escape Sequences</title> 
  -->
  <title>反斜杠转义序列</title>
      <tgroup cols="2">
      <thead>
       <row>
        <!-- <entry>Backslash Escape Sequence</> -->
<entry>反斜杠转义序列</>
        <!-- <entry>Interpretation</entry> -->
<entry>解释</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
        <!-- <entry>backspace</entry> -->
<entry>退格</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
        <!-- <entry>form feed</entry> -->
<entry>进纸</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
        <!-- <entry>newline</entry> -->
<entry>换行</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <!-- <entry>carriage return</entry> -->
<entry>回车</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <!-- <entry>tab</entry> -->
<entry>水平制表符</entry>
       </row>
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0 - 7)
        </entry>
        <!-- <entry>octal byte value</entry> -->
<entry>八进制字节值</entry>
       </row>
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0 - 9, A - F)
        </entry>
        <!-- <entry>hexadecimal byte value</entry> -->
<entry>十六进制字节值</entry>
       </row>
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0 - 9, A - F)
        </entry>
        <!-- <entry>16 or 32-bit hexadecimal Unicode character value</entry> -->
<entry>16或32位十六进制Unicode字符值</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

    <para>
     <!-- 
 Any other
     character following a backslash is taken literally. Thus, to
     include a backslash character, write two backslashes (<literal>\\</>).
     Also, a single quote can be included in an escape string by writing
     <literal>\'</literal>, in addition to the normal way of <literal>''</>. 
 -->
任何其它跟在反斜杠后面的字符都当做文本看待。因此，要在字符串常量里包含反斜杠，
则写两个反斜杠(<literal>\\</>)。另外，PostgreSQL 允许用一个反斜杠来转义单引号<literal>\'</literal>，
不过，将来版本 的 PostgreSQL 将不允许这么用。所以最好坚持使用符合标准的<literal>''</>。 
    </para>

    <!-- 
<para>
     It is your responsibility that the byte sequences you create,
     especially when using the octal or hexadecimal escapes, compose
     valid characters in the server character set encoding.  When the
     server encoding is UTF-8, then the Unicode escapes or the
     alternative Unicode escape syntax, explained
     in <xref linkend="sql-syntax-strings-uescape">, should be used
     instead.  (The alternative would be doing the UTF-8 encoding by
     hand and writing out the bytes, which would be very cumbersome.)
    </para> 
-->
<para>
你有必要为你所创建的字节序列（特别是在使用八进制或十六进制转义时）编写有效的服务器字符集编码字符。
当服务器编码是UTF-8时，应该使用Unicode转义或另一种Unicode转义语法（参阅<xref linkend="sql-syntax-strings-uescape">）。
（后者通过写出字节来处理UTF-8字符集，这样做是很繁琐的）。
</para> 

    <!-- 
<para>
     The Unicode escape syntax works fully only when the server
     encoding is <literal>UTF8</>.  When other server encodings are
     used, only code points in the ASCII range (up
     to <literal>\u007F</>) can be specified.  Both the 4-digit and
     the 8-digit form can be used to specify UTF-16 surrogate pairs to
     compose characters with code points larger than U+FFFF, although
     the availability of the 8-digit form technically makes this
     unnecessary.  (When surrogate pairs are used when the server
     encoding is <literal>UTF8</>, they are first combined into a
     single code point that is then encoded in UTF-8.)
    </para> 
-->
<para>
只有服务器字符集是<literal>UTF8</>时，才会完全使用Unicode转义语法。
当使用其他服务器字符集时，只有在ASCII内的（最多<literal>\u007F</>）代码点可以被声明。
4位和8位的数字形式可以被用来将UTF-16代理对声明为大于U+FFFF的带有代码点的字符，
尽管8位数字形式技术的可用性使得这样做没有必要。（当服务器编码是<literal>UTF8</>时使用代理对，
首先，它们结合成一个单一的代码点，然后再用UTF-8编码）
</para>
    <caution>
    <!-- 
<para>
     If the configuration parameter
     <xref linkend="guc-standard-conforming-strings"> is <literal>off</>,
     then <productname>PostgreSQL</productname> recognizes backslash escapes
     in both regular and escape string constants.  However, as of
     <productname>PostgreSQL</> 9.1, the default is <literal>on</>, meaning
     that backslash escapes are recognized only in escape string constants.
     This behavior is more standards-compliant, but might break applications
     which rely on the historical behavior, where backslash escapes
     were always recognized.  As a workaround, you can set this parameter
     to <literal>off</>, but it is better to migrate away from using backslash
     escapes.  If you need to use a backslash escape to represent a special
     character, write the string constant with an <literal>E</>.
    </para> 
-->
<para>
如果配置参数<xref linkend="guc-standard-conforming-strings">的值是<literal>off</>，
那么<productname>PostgreSQL</productname>将能够识别常规和转义字符串常量中的反斜杠转义。
然而，在<productname>PostgreSQL</>9.1中，参数值默认为<literal>on</>，这意味着反斜杠转义只能在转义字符串常量中识别。
这个行为更为标准兼容，但是可能会使依赖于历史行为的应用程序崩溃，因为历史行为中反斜杠转义总是能被识别。
作为一个变通方案，你可以设置这个参数为<literal>off</>，但是最好是不使用反斜杠转义。如果你需要使用反斜杠转义来表示特殊的字符，
那么请在字符串常量前加上<literal>E</>。
</para> 
    <!-- 
<para>
     In addition to <varname>standard_conforming_strings</>, the configuration
     parameters <xref linkend="guc-escape-string-warning"> and
     <xref linkend="guc-backslash-quote"> govern treatment of backslashes
     in string constants.
    </para> 
-->
<para>
除<varname>standard_conforming_strings</>之外，<xref linkend="guc-escape-string-warning">
和<xref linkend="guc-backslash-quote">配置参数也影响字符串常量中反斜杠的处理。
</para>
    </caution>

    <!-- 
<para>
     The character with the code zero cannot be in a string constant.
    </para> 
-->
<para>
编码为零的字符不允许出现在字符串常量中。
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
    <!-- 
<title>String Constants with Unicode Escapes</title> 
-->
<title>Unicode转义字符串常量</title>
    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Unicode escape</primary>
     <secondary>in string constants</secondary>
    </indexterm>

    <para>
     <!-- 
 <productname>PostgreSQL</productname> also supports another type
     of escape syntax for strings that allows specifying arbitrary
     Unicode characters by code point.  A Unicode escape string
     constant starts with <literal>U&amp;</literal> (upper or lower case
     letter U followed by ampersand) immediately before the opening
     quote, without any spaces in between, for
     example <literal>U&amp;'foo'</literal>.  (Note that this creates an
     ambiguity with the operator <literal>&amp;</literal>.  Use spaces
     around the operator to avoid this problem.)  Inside the quotes,
     Unicode characters can be specified in escaped form by writing a
     backslash followed by the four-digit hexadecimal code point
     number or alternatively a backslash followed by a plus sign
     followed by a six-digit hexadecimal code point number.  For
     example, the string <literal>'data'</literal> could be written as 
 -->
<productname>PostgreSQL</productname>也支持其他类型的字符串转义语法，
允许声明任意的带有代码点标记的Unicode字符。一个转义Unicode字符常量以
<literal>U&amp;</literal>开始（大/小写U后紧跟有&amp;符号）紧跟着打开的单引号，
之间没有空格，例如<literal>U&amp;'foo'</literal>。（这可能产生和操作符<literal>&amp;</literal>
之间的歧义。可以在操作符周围加上空格来避免该问题。）在引号中，
通过写一个后面跟有四位十六进制代码点或跟有加号和六位十六进制代码点的反斜杠，
Unicode字符可以写成转义格式。例如，<literal>'data'</literal>可以写成： 
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
     <!-- 
 The following less trivial example writes the Russian
     word <quote>slon</quote> (elephant) in Cyrillic letters: 
 -->
下例以西里尔字母写俄文<quote>slon</quote>（象）。  
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>

    <para>
     <!-- 
 If a different escape character than backslash is desired, it can
     be specified using
     the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
     clause after the string, for example: 
 -->
如果需要一个非反斜杠的不同的转义，可以通过在字符串之后使用
<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>语句来进行声明，如：  
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
     <!-- 
 The escape character can be any single character other than a
     hexadecimal digit, the plus sign, a single quote, a double quote,
     or a whitespace character. 
 -->
转义字符可以是一个十六进制数字以外的任何单个字符，加号，一个单引号，
一个双引号，或一个空白字符。 
    </para>

    <!-- 
<para>
     The Unicode escape syntax works only when the server encoding is
     <literal>UTF8</>.  When other server encodings are used, only
     code points in the ASCII range (up to <literal>\007F</literal>)
     can be specified.  Both the 4-digit and the 6-digit form can be
     used to specify UTF-16 surrogate pairs to compose characters with
     code points larger than U+FFFF, although the availability of the
     6-digit form technically makes this unnecessary.  (When surrogate
     pairs are used when the server encoding is <literal>UTF8</>, they
     are first combined into a single code point that is then encoded
     in UTF-8.)
    </para> 
-->
<para>
只有服务器字符集是<literal>UTF8</>时，才会完全使用Unicode转义语法。
当使用其他服务器字符集时，只有在ASCII内的（最多<literal>\007F</literal>）代码点可以被声明。
4位和6位的数字形式可以被用来将UTF-16代理对声明为大于U+FFFF的带有代码点的字符，
尽管6位数字形式技术的可用性使得这样做没有必要。（当服务器编码是<literal>UTF8</>时使用代理对，
首先，它们结合成一个单一的代码点，然后再用UTF-8编码。）   
</para>
    <!-- 
<para>
     Also, the Unicode escape syntax for string constants only works
     when the configuration
     parameter <xref linkend="guc-standard-conforming-strings"> is
     turned on.  This is because otherwise this syntax could confuse
     clients that parse the SQL statements to the point that it could
     lead to SQL injections and similar security issues.  If the
     parameter is set to off, this syntax will be rejected with an
     error message.
    </para> 
-->
<para>
同样，字符串常量的Unicode转义语法只有当配置参数<xref linkend="guc-standard-conforming-strings">
启用时才能生效。否则，该语法在解析SQL语法时给客户端造成混淆，导致SQL注入或其他安全问题。
如果该参数设为OFF，该语法会带着一条错误消息一起被拒绝。 
</para> 
    <!-- 
<para>
     To include the escape character in the string literally, write it
     twice.
    </para> 
-->
<para>
为了将转义字符写到字符串中，可以将它写两次。 
</para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
    <!-- 
<title>Dollar-quoted String Constants</title> 
-->
<title>美元符引用字符串常量</title>
     <indexterm>
      <primary>dollar quoting</primary>
     </indexterm>

    <para>
     <!-- 
 While the standard syntax for specifying string constants is usually
     convenient, it can be difficult to understand when the desired string
     contains many single quotes or backslashes, since each of those must
     be doubled. To allow more readable queries in such situations,
     <productname>PostgreSQL</productname> provides another way, called
     <quote>dollar quoting</quote>, to write string constants.
     A dollar-quoted string constant
     consists of a dollar sign (<literal>$</literal>), an optional
     <quote>tag</quote> of zero or more characters, another dollar
     sign, an arbitrary sequence of characters that makes up the
     string content, a dollar sign, the same tag that began this
     dollar quote, and a dollar sign. For example, here are two
     different ways to specify the string <quote>Dianne's horse</>
     using dollar quoting: 
 -->
尽管声明字符串常量的标准方法通常都很方便，但是如果字符串中包含很多单引号或者反斜杠，
那么理解字符串的内容可能就会变得很苦涩，因为每个单引号都要加倍。
为了让这种场合下的查询更具可读性，<productname>PostgreSQL</productname>允许另外一种称作
<quote>美元符引用</quote>的字符串常量书写办法。一个通过美元符引用声明的字符串常量由一个美元符号
(<literal>$</literal>)、零个或多个字符组成的<quote>标签</quote>、另一个美元符号、
组成字符串常量的任意字符序列、一个美元符号、与前面相同的标签、一个美元符号组成的。
比如，下面是两个不同的用美元符引用的方法声明<quote>Dianne's horse</>的例子： 
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
     <!-- 
 Notice that inside the dollar-quoted string, single quotes can be
     used without needing to be escaped.  Indeed, no characters inside
     a dollar-quoted string are ever escaped: the string content is always
     written literally.  Backslashes are not special, and neither are
     dollar signs, unless they are part of a sequence matching the opening
     tag. 
 -->
请注意，在美元符引用的字符串里，单引号不允许转义。实际上，在一个美元符引用的字符串里，
不允许转义任何字符：字符串内容总是按照字面内容书写。反斜杠不是特殊的、
美元符自己也不是特殊的(除非它们和开标签的一部分匹配)。 
    </para>

    <para>
     <!-- 
 It is possible to nest dollar-quoted string constants by choosing
     different tags at each nesting level.  This is most commonly used in
     writing function definitions.  For example: 
 -->
我们可以通过在不同嵌套级别使用不同的"标签"来实现嵌套。最常见的是写函数定义的时候。比如： 
<programlisting>
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
     <!-- 
 Here, the sequence <literal>$q$[\t\r\n\v\\]$q$</> represents a
     dollar-quoted literal string <literal>[\t\r\n\v\\]</>, which will
     be recognized when the function body is executed by
     <productname>PostgreSQL</>.  But since the sequence does not match
     the outer dollar quoting delimiter <literal>$function$</>, it is
     just some more characters within the constant so far as the outer
     string is concerned. 
 -->
这里，序列<literal>$q$[\t\r\n\v\\]$q$</>表示一个美元符引用的字符串文本<literal>[\t\r\n\v\\]</>，
在函数体被<productname>PostgreSQL</>执行的时候，它将被识别出来。
但是因为这个序列不匹配外层的美元符引用分隔符<literal>$function$</> ，所以只要考虑了外层字符串，
它就只是常量里面的普通字符而已。 
    </para>

    <!-- 
<para>
     The tag, if any, of a dollar-quoted string follows the same rules
     as an unquoted identifier, except that it cannot contain a dollar sign.
     Tags are case sensitive, so <literal>$tag$String content$tag$</literal>
     is correct, but <literal>$TAG$String content$tag$</literal> is not.
    </para> 
-->
<para>
一个美元符引用字符串的标签(如果有标签的话),遵循和无引号包围的标识符相同的规则，
只是它不能包含美元符。标签是大小写敏感的，因此<literal>$tag$String content$tag$</literal>
是正确的，而<literal>$TAG$String content$tag$</literal>则是错误的。
</para> 
    <!-- 
<para>
     A dollar-quoted string that follows a keyword or identifier must
     be separated from it by whitespace; otherwise the dollar quoting
     delimiter would be taken as part of the preceding identifier.
    </para> 
-->
<para>
一个后面紧跟着关键字或者标识符的美元符引用字符串必须用空白与其后的关键字或者标识符隔开；
否则美元符引用分隔符将会被当作标识符的开头部分。
</para> 
    <!-- 
<para>
     Dollar quoting is not part of the SQL standard, but it is often a more
     convenient way to write complicated string literals than the
     standard-compliant single quote syntax.  It is particularly useful when
     representing string constants inside other constants, as is often needed
     in procedural function definitions.  With single-quote syntax, each
     backslash in the above example would have to be written as four
     backslashes, which would be reduced to two backslashes in parsing the
     original string constant, and then to one when the inner string constant
     is re-parsed during function execution.
    </para> 
-->
<para>
美元符引用不是 SQL 标准，但是在写复杂的字符串文本的时候，它通常比标准的单引号语法更方便。
尤其是在其它常量里表现字符串常量的时候更有用，比如在过程函数定义里。如果用单引号语法，
每个上面例子里的每个反斜杠都必须写四个，它们在作为字符串文本分析的时候会减少为两个，
然后在函数执行的时候在内层字符串常量里会再次被解析为一个。
</para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
    <!-- 
<title>Bit-string Constants</title> 
-->
<title>位串常量</title>
    <indexterm zone="sql-syntax-bit-strings">
     <primary>bit string</primary>
     <secondary>constant</secondary>
    </indexterm>

    <!-- 
<para>
     Bit-string constants look like regular string constants with a
     <literal>B</literal> (upper or lower case) immediately before the
     opening quote (no intervening whitespace), e.g.,
     <literal>B'1001'</literal>.  The only characters allowed within
     bit-string constants are <literal>0</literal> and
     <literal>1</literal>.
    </para> 
-->
<para>
位串常量看起来很像在开引号前面有一个<literal>B</literal>(大写或小写)的普通字符串
(它们之间没有空白)，比如<literal>B'1001'</literal>。位串常量里可以用的字符只有<literal>0</literal>
和<literal>1</literal>。
</para>
    <!-- 
<para>
     Alternatively, bit-string constants can be specified in hexadecimal
     notation, using a leading <literal>X</literal> (upper or lower case),
     e.g., <literal>X'1FF'</literal>.  This notation is equivalent to
     a bit-string constant with four binary digits for each hexadecimal digit.
    </para> 
-->
<para>
另外，位串常量可以用十六进制表示法声明，方法是使用前缀<literal>X</literal>(大写或者小写)，
比如<literal>X'1FF'</literal>，其中的每个十六进制位等效于四个二进制位。
</para>
    <!-- 
<para>
     Both forms of bit-string constant can be continued
     across lines in the same way as regular string constants.
     Dollar quoting cannot be used in a bit-string constant.
    </para> 
-->
<para>
两种形式的位串常量都可以像普通字符串常量那样跨行连续。位串常量不能用美元符引用。
</para>
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
    <!-- 
<title>Numeric Constants</title> 
-->
<title>数值常量</title>
    <indexterm>
     <primary>number</primary>
     <secondary>constant</secondary>
    </indexterm>

    <para>
     <!-- 
 Numeric constants are accepted in these general forms: 
 -->
数值常量接受下列通用的形式： 
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
     <!-- 
 where <replaceable>digits</replaceable> is one or more decimal
     digits (0 through 9).  At least one digit must be before or after the
     decimal point, if one is used.  At least one digit must follow the
     exponent marker (<literal>e</literal>), if one is present.
     There cannot be any spaces or other characters embedded in the
     constant.  Note that any leading plus or minus sign is not actually
     considered part of the constant; it is an operator applied to the
     constant. 
 -->
这里的<replaceable>digits</replaceable>是一个或多个十进制数字(0-9)。
如果有小数点，那么至少有一位在小数点前面或后面。
如果出现了指数标记(<literal>e</literal>)那么至少有一个数字跟在它后面。
在常量里不能有空格或者其它字符。请注意任何前导正号或负号实际上都不认为是常量的一部分；
它是施加于常量的一个操作符。 
    </para>

    <para>
     <!-- 
 These are some examples of valid numeric constants:
 -->
这里是一些合法的数值常量的例子：  
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>

    <!-- 
<para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
     A numeric constant that contains neither a decimal point nor an
     exponent is initially presumed to be type <type>integer</> if its
     value fits in type <type>integer</> (32 bits); otherwise it is
     presumed to be type <type>bigint</> if its
     value fits in type <type>bigint</> (64 bits); otherwise it is
     taken to be type <type>numeric</>.  Constants that contain decimal
     points and/or exponents are always initially presumed to be type
     <type>numeric</>.
    </para> 
-->
<para>
<indexterm><primary>integer</primary></indexterm>
<indexterm><primary>bigint</primary></indexterm>
<indexterm><primary>numeric</primary></indexterm>
如果一个数值常量既不包含小数点，也不包含指数，
那么如果它的数值可以放在<type>integer</>类型中(32位)，则认为它是<type>integer</>类型；
如果它的数值可以放在<type>bigint</>中(64位)，则认为它是<type>bigint</>，
否则认为它是<type>numeric</>类型。包含小数点和/或指数的常量总是被认为是
<type>numeric</>类型。 
</para> 
    <para>
     <!-- 
 The initially assigned data type of a numeric constant is just a
     starting point for the type resolution algorithms.  In most cases
     the constant will be automatically coerced to the most
     appropriate type depending on context.  When necessary, you can
     force a numeric value to be interpreted as a specific data type
     by casting it.<indexterm><primary>type cast</primary></indexterm>
     For example, you can force a numeric value to be treated as type
     <type>real</> (<type>float4</>) by writing: 
 -->
给一个数值常量赋予初始数据类型只是类型解析算法的开端。
在大多数情况下该常量会根据环境被自动强制转换成最合适的类型。
必要时，你可以通过强制类型转换把一个数值解析成特定的数据类型。<indexterm><primary>type cast</primary></indexterm>
比如，你可以强制要求把一个数值当作<type>real</> (<type>float4</>)类型来看，方法是这么写：
<programlisting>
REAL '1.23'  -- 字符串风格
1.23::REAL   -- PostgreSQL (历史的) 风格
</programlisting>

     <!-- 
 These are actually just special cases of the general casting
     notations discussed next. 
 -->
这些实际上只是下面讨论的通用转换的特例。 
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-generic">
    <!-- 
<title>Constants of Other Types</title> 
-->
<title>其它类型的常量</title>
    <indexterm>
     <primary>data type</primary>
     <secondary>constant</secondary>
    </indexterm>

    <para>
     <!-- 
 A constant of an <emphasis>arbitrary</emphasis> type can be
     entered using any one of the following notations: 
 -->
<emphasis>任意</emphasis>类型的常量都可以用下列表示法中的任何一种来输入： 
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
     <!-- 
 The string constant's text is passed to the input conversion
     routine for the type called <replaceable>type</replaceable>. The
     result is a constant of the indicated type.  The explicit type
     cast can be omitted if there is no ambiguity as to the type the
     constant must be (for example, when it is assigned directly to a
     table column), in which case it is automatically coerced.
 -->
其中字符串常量的文本将会被代入到类型<replaceable>type</replaceable>的输入转换过程。其结果是一个该类型的常量。
如果不存在该常量所属类型的歧义，那么可以省略明确的类型转换(比如，当你把它直接赋予一个表字段的时候)，
这种情况下它会自动转换。
    </para>

    <!-- 
<para>
     The string constant can be written using either regular SQL
     notation or dollar-quoting.
    </para> 
-->
<para>
其中的字符串常量可以用普通 SQL 表示法或者美元符引用来书写。
</para> 
    <para>
     <!-- 
 It is also possible to specify a type coercion using a function-like
     syntax: 
 -->
我们还可以用函数风格的语法来声明类型转换： 
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
     <!-- 
 but not all type names can be used in this way; see <xref
     linkend="sql-syntax-type-casts"> for details. 
 -->
不过并非所有类型名都可以这样使用；参阅<xref linkend="sql-syntax-type-casts">获取细节。 
    </para>

    <!-- 
<para>
     The <literal>::</literal>, <literal>CAST()</literal>, and
     function-call syntaxes can also be used to specify run-time type
     conversions of arbitrary expressions, as discussed in <xref
     linkend="sql-syntax-type-casts">.  To avoid syntactic ambiguity, the
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax can only be used to specify the type of a simple literal constant.
     Another restriction on the
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax is that it does not work for array types; use <literal>::</literal>
     or <literal>CAST()</literal> to specify the type of an array constant.
    </para> 
-->
<para>
<literal>::</literal>，<literal>CAST()</literal>
和函数调用语法也可以用于声明任意表达式的运行时类型转换(如<xref linkend="sql-syntax-type-casts">
中讨论的那样)。为了避免语法歧义，<literal><replaceable>type</> '<replaceable>string</>'</literal>
的形式只能用于声明一个简单的字面常量的类型。<literal><replaceable>type</> '<replaceable>string</>'</literal>
的另外一个限制是它不能用于数组类型(要用<literal>::</literal>或  <literal>CAST()</literal>
声明一个数组常量的类型)。
</para>
    <!-- 
<para>
     The <literal>CAST()</> syntax conforms to SQL.  The
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax is a generalization of the standard: SQL specifies this syntax only
     for a few data types, but <productname>PostgreSQL</productname> allows it
     for all types.  The syntax with
     <literal>::</literal> is historical <productname>PostgreSQL</productname>
     usage, as is the function-call syntax.
    </para> 
-->
<para>
<literal>CAST()</>语法遵循 SQL 标准。<literal><replaceable>type</> '<replaceable>string</>'</literal>
语法是标准的一个推广：SQL 只是给少数几种数据类型声明了这个语法，但<productname>PostgreSQL</productname>
允许将其用于所有类型。<literal>::</literal>和函数调用的语法是<productname>PostgreSQL</productname>的历史用法。
</para> 
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
   <!-- 
   <title>Operators</title> 
   -->
<title>操作符</title>
   <indexterm zone="sql-syntax-operators">
    <primary>operator</primary>
    <secondary>syntax</secondary>
   </indexterm>

   <para>
    <!-- 
An operator name is a sequence of up to <symbol>NAMEDATALEN</symbol>-1
    (63 by default) characters from the following list: 
-->
一个操作符是最多 <symbol>NAMEDATALEN</symbol>-1 个(缺省63个)下列字符的序列： 
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

    <!-- 
There are a few restrictions on operator names, however: 
-->
不过，有几个限制：
    <itemizedlist>
     <listitem>
      <!-- 
  <para>
       <literal>&#045;-</literal> and <literal>/*</literal> cannot appear
       anywhere in an operator name, since they will be taken as the
       start of a comment.
      </para> 
  -->
<para>
<literal>--</literal> 和 <literal>/*</literal>不能出现在操作符中的任何地方，
因为它们会被当做注释开始对待。
</para>  
     </listitem>

     <listitem>
      <para>
       <!-- 
   A multiple-character operator name cannot end in <literal>+</> or <literal>-</>,
       unless the name also contains at least one of these characters: 
   -->
多字符操作符不能以<literal>+</> 或 <literal>-</>结束，除非其中至少还包含下列操作符之一：    
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
       <!-- 
   For example, <literal>@-</literal> is an allowed operator name,
       but <literal>*-</literal> is not.  This restriction allows
       <productname>PostgreSQL</productname> to parse SQL-compliant
       queries without requiring spaces between tokens. 
   -->
比如，<literal>@-</literal>是允许的操作符，但<literal>*-</literal>不是。
这个限制允许<productname>PostgreSQL</productname>在不要求记号之间有空白的情况下分析 SQL 兼容的查询。   
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <!-- 
   <para>
    When working with non-SQL-standard operator names, you will usually
    need to separate adjacent operators with spaces to avoid ambiguity.
    For example, if you have defined a left unary operator named <literal>@</literal>,
    you cannot write <literal>X*@Y</literal>; you must write
    <literal>X* @Y</literal> to ensure that
    <productname>PostgreSQL</productname> reads it as two operator names
    not one.
   </para> 
   -->
<para>
当你使用非 SQL 标准的操作符的时候，你通常需要用空白分隔相邻的操作符以避免歧义。
比如，如果你定义了一个叫<literal>@</literal>的左单目操作符，那么你就不能写成
<literal>X*@Y</literal>；而是要写成<literal>X* @Y</literal>以确保<productname>PostgreSQL</productname>
把它读成两个操作符，而不是一个。
</para>    
  </sect2>

  <sect2 id="sql-syntax-special-chars">
   <!-- 
   <title>Special Characters</title> 
   -->
<title>特殊字符</title>
  <para>
  <!-- 
  Some characters that are not alphanumeric have a special meaning
   that is different from being an operator.  Details on the usage can
   be found at the location where the respective syntax element is
   described.  This section only exists to advise the existence and
   summarize the purposes of these characters. 
   -->
有些非字母数字字符有一些特殊含义，因此不能用做操作符。
它们的用法细节可以在相应的描述语法元素的地方找到。
本节只是描述它们的存在和概括一下这些字符的目的。
   <itemizedlist>
    <listitem>
     <!-- 
 <para>
      A dollar sign (<literal>$</literal>) followed by digits is used
      to represent a positional parameter in the body of a function
      definition or a prepared statement.  In other contexts the
      dollar sign can be part of an identifier or a dollar-quoted string
      constant.
     </para>
 -->
<para> 
美元符号(<literal>$</literal>)后面跟着数字用于在一个函数体定义或者预备语句中表示参数的位置。
在其它环境里美元符号可能是一个标识符名字或者是一个美元符引用的字符串常量的一部分。 
</para> 
    </listitem>

    <listitem>
     <!-- 
 <para>
      Parentheses (<literal>()</literal>) have their usual meaning to
      group expressions and enforce precedence.  In some cases
      parentheses are required as part of the fixed syntax of a
      particular SQL command.
     </para>
 -->
<para>
圆括弧(<literal>()</literal>)用于分组和强制优先级的时候含义与平常一样。
有些场合里圆括弧是作为一个特定 SQL 命令的固定语法的一部分要求的。
</para> 
    </listitem>

    <listitem>
     <!-- 
 <para>
      Brackets (<literal>[]</literal>) are used to select the elements
      of an array.  See <xref linkend="arrays"> for more information
      on arrays.
     </para> 
 -->
<para>
方括弧(<literal>[]</literal>)用于选取数组元素。参阅<xref linkend="arrays">获取更多信息。
</para> 
    </listitem>

    <listitem>
     <!-- 
 <para>
      Commas (<literal>,</literal>) are used in some syntactical
      constructs to separate the elements of a list.
     </para> 
 -->
<para>
逗号(<literal>,</literal>)在一些语法构造里用于分隔一个列表的元素。
</para> 
    </listitem>

    <listitem>
     <!-- 
 <para>
      The semicolon (<literal>;</literal>) terminates an SQL command.
      It cannot appear anywhere within a command, except within a
      string constant or quoted identifier.
     </para>
 -->
<para>
分号(<literal>;</literal>)结束一条 SQL 命令。它不能出现在一条命令里的任何地方，
除了在引号包围的字符串常量或者标识符中。
</para> 
    </listitem>

    <listitem>
     <!-- 
 <para>
      The colon (<literal>:</literal>) is used to select
      <quote>slices</quote> from arrays. (See <xref
      linkend="arrays">.)  In certain SQL dialects (such as Embedded
      SQL), the colon is used to prefix variable names.
     </para> 
 -->
<para>
冒号(<literal>:</literal>)用于从数组中选取<quote>片段</quote>(参阅
<xref linkend="arrays">)。在一些 SQL 方言里(比如嵌入 SQL)，冒号用于前缀变量名。
</para> 
    </listitem>

    <listitem>
     <!-- 
 <para>
      The asterisk (<literal>*</literal>) is used in some contexts to denote
      all the fields of a table row or composite value.  It also
      has a special meaning when used as the argument of an
      aggregate function, namely that the aggregate does not require
      any explicit parameter.
     </para> 
 -->
<para>
星号(<literal>*</literal>)在某些环境里表示一个表的全部字段或者一个复合类型的值。
在用作聚合函数的参数时还表示该聚合并不需要明确的参数。
</para> 
    </listitem>

    <listitem>
     <!-- 
 <para>
      The period (<literal>.</literal>) is used in numeric
      constants, and to separate schema, table, and column names.
     </para> 
 -->
<para>
句点(<literal>.</literal>)用在数字常量里，并用于分隔模式、表、字段名。
</para>  
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
   <!-- 
   <title>Comments</title> 
   -->
<title>注释</title>
   <indexterm zone="sql-syntax-comments">
    <primary>comment</primary>
    <secondary sortas="SQL">in SQL</secondary>
   </indexterm>

   <para>
    <!-- 
A comment is a sequence of characters beginning with
    double dashes and extending to the end of the line, e.g.:
-->
注释是任意以双划线开头并延伸到行尾的任意字符序列，比如：
<programlisting>
-- 这是标准的 SQL 注释 
</programlisting>
   </para>

   <para>
    <!-- 
Alternatively, C-style block comments can be used: 
-->
另外，还可以使用C风格的块注释：
<programlisting>
/* 多行注释
 * 可以嵌套: /* 被嵌套的块注释 */
 */
</programlisting>
    <!-- 
where the comment begins with <literal>/*</literal> and extends to
    the matching occurrence of <literal>*/</literal>. These block
    comments nest, as specified in the SQL standard but unlike C, so that one can
    comment out larger blocks of code that might contain existing block
    comments. 
-->
这里注释以<literal>/*</literal>开头并扩展到对应的<literal>*/</literal>。
这些块注释可以嵌套，就像 SQL标准里说的那样(但和 C 不一样)，
因此我们可以注释掉一大块已经包含块注释的代码。
   </para>

   <!-- 
   <para>
    A comment is removed from the input stream before further syntax
    analysis and is effectively replaced by whitespace.
   </para> 
   -->
<para>
注释在进一步的语法分析之前被从输入流中删除并用空白代替。
</para>   
  </sect2>

  <sect2 id="sql-precedence">
   <!-- 
   <title>Operator Precedence</title> 
   -->
<title>操作符优先级</title>
   <indexterm zone="sql-precedence">
    <primary>operator</primary>
    <secondary>precedence</secondary>
   </indexterm>

   <para>
    <!-- 
<xref linkend="sql-precedence-table"> shows the precedence and
    associativity of the operators in <productname>PostgreSQL</>.
    Most operators have the same precedence and are left-associative.
    The precedence and associativity of the operators is hard-wired
    into the parser.  This can lead to non-intuitive behavior; for
    example the Boolean operators <literal>&lt;</> and
    <literal>&gt;</> have a different precedence than the Boolean
    operators <literal>&lt;=</> and <literal>&gt;=</>.  Also, you will
    sometimes need to add parentheses when using combinations of
    binary and unary operators.  For instance: 
-->
<xref linkend="sql-precedence-table">显示了<productname>PostgreSQL</>
里面的操作符的优先级和关联性。大多数操作符都有相同的优先级并且都是左关联的。
操作符的优先级和关联性是硬连接到解析器的。这种情况可能会有不那么直观的行为；
比如，布尔操作符<literal>&lt;</>和<literal>&gt;</>与布尔操作符<literal>&lt;=</>和
<literal>&gt;=</>之间有着不同的优先级。同样，当你把双目和单目操作符组合使用的时候，
有时候也需要加圆括弧。比如：
<programlisting>
SELECT 5 ! - 6;
</programlisting>
  <!-- 
  will be parsed as:
  -->
 会被分析成： 
<programlisting>
SELECT 5 ! (- 6);
</programlisting>
    <!-- 
because the parser has no idea &mdash; until it is too late
    &mdash; that <token>!</token> is defined as a postfix operator,
    not an infix one.  To get the desired behavior in this case, you
    must write: 
-->
因为解析器不知道<token>!</token>被定义成了后缀操作符，而不是中缀操作符
(知道的时候只能是太晚了)。要在本例中获得你需要的特性，你要写成：
<programlisting>
SELECT (5 !) - 6;
</programlisting>
    <!-- 
This is the price one pays for extensibility. 
-->
这是我们为扩展性付出的代价。
   </para>

   <table id="sql-precedence-table">
    <!-- 
<title>Operator Precedence (decreasing)</title> 
-->
<title>操作符优先级(递减)</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!-- 
   <entry>Operator/Element</entry>
       <entry>Associativity</entry>
       <entry>Description</entry> 
   -->
   <entry>操作符/元素</entry>
       <entry>关联性</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
       <!-- 
   <entry>left</entry>
       <entry>table/column name separator</entry>
   -->
   <entry>左</entry>
       <entry>表/字段名分隔符</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
       <!-- 
   <entry>left</entry>
       <entry><productname>PostgreSQL</productname>-style typecast</entry>
   -->
   <entry>左</entry>
       <entry><productname>PostgreSQL</productname>特有的类型转换操作符</entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
       <!-- 
   <entry>left</entry>
       <entry>array element selection</entry> 
   -->
   <entry>左</entry>
       <entry>数组元素选择</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <!-- 
   <entry>right</entry>
       <entry>unary plus, unary minus</entry> 
   -->
   <entry>右</entry>
       <entry>单目正号，单目负号</entry>
      </row>

      <row>
       <entry><token>^</token></entry>
       <!-- 
   <entry>left</entry>
       <entry>exponentiation</entry> 
   -->
   <entry>左</entry>
       <entry>幂</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <!-- 
   <entry>left</entry>
       <entry>multiplication, division, modulo</entry> 
   -->
   <entry>左</entry>
       <entry>乘，除，模</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <!-- 
   <entry>left</entry>
       <entry>addition, subtraction</entry> 
   -->
   <entry>左</entry>
       <entry>加，减</entry>
      </row>

      <row>
       <entry><token>IS</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</>, <literal>IS FALSE</>, <literal>IS NULL</>, etc</entry>
      </row>

      <row>
       <entry><token>ISNULL</token></entry>
       <entry></entry>
       <!-- 
   <entry>test for null</entry>
   -->
   <entry>测试是否为NULL</entry>
      </row>

      <row>
       <entry><token>NOTNULL</token></entry>
       <entry></entry>
       <!-- 
   <entry>test for not null</entry> 
   -->
   <entry>测试是否不为NULL</entry>
      </row>

      <row>
       <!-- 
   <entry>(any other)</entry>
       <entry>left</entry>
       <entry>all other native and user-defined operators</entry> 
   -->
   <entry>(任何其他的)</entry>
       <entry>左</entry>
       <entry>所有其他的本地和用户定义操作符</entry>
      </row>

      <row>
       <entry><token>IN</token></entry>
       <entry></entry>
       <!-- 
   <entry>set membership</entry> 
   -->
   <entry>集合成员</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token></entry>
       <entry></entry>
       <!-- 
   <entry>range containment</entry> 
   -->
   <entry>范围包含</entry>
      </row>

      <row>
       <entry><token>OVERLAPS</token></entry>
       <entry></entry>
       <!-- 
   <entry>time interval overlap</entry> 
   -->
   <entry>时间间隔重叠</entry>
      </row>

      <row>
       <entry><token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
       <!-- 
   <entry>string pattern matching</entry> 
   -->
   <entry>字符串模式匹配</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token></entry>
       <entry></entry>
       <!-- 
   <entry>less than, greater than</entry> 
   -->
   <entry>小于，大于</entry>
      </row>

      <row>
       <entry><token>=</token></entry>
       <!-- 
   <entry>right</entry>
       <entry>equality, assignment</entry> 
   -->
   <entry>右</entry>
       <entry>等于，赋值</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
       <!-- 
   <entry>right</entry>
       <entry>logical negation</entry> 
   -->
   <entry>右</entry>
       <entry>逻辑非</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
       <!-- 
   <entry>left</entry>
       <entry>logical conjunction</entry> 
   -->
   <entry>左</entry>
       <entry>逻辑与</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
       <!-- 
   <entry>left</entry>
       <entry>logical disjunction</entry> 
   -->
   <entry>左</entry>
       <entry>逻辑或</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!-- 
   <para>
    Note that the operator precedence rules also apply to user-defined
    operators that have the same names as the built-in operators
    mentioned above.  For example, if you define a
    <quote>+</quote> operator for some custom data type it will have
    the same precedence as the built-in <quote>+</quote> operator, no
    matter what yours does.
   </para> 
   -->
<para>
请注意操作符优先级也适用于和上面提到的内置操作符同名的用户定义操作符。
比如，如果你为一些客户数据类型定义一个<quote>+</quote>操作符，
那么它和内置的<quote>+</quote>操作符有同样的优先级，不管用它来干什么。   
</para>   
   <para>
    <!-- 
When a schema-qualified operator name is used in the
    <literal>OPERATOR</> syntax, as for example in: 
-->
如果在<literal>OPERATOR</>语法里使用了模式修饰的操作符名，比如：
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    <!-- 
the <literal>OPERATOR</> construct is taken to have the default precedence
    shown in <xref linkend="sql-precedence-table"> for <quote>any other</> operator.  This is true no matter
    which specific operator appears inside <literal>OPERATOR()</>. 
-->
那么<literal>OPERATOR</>构造就会有<xref linkend="sql-precedence-table">
里面为<quote>任何其它的</> 操作符显示的缺省优先级。不管什么特定的操作符出现在
<literal>OPERATOR()</>里都是这样。
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
  <!-- 
  <title>Value Expressions</title> 
  -->
<title>值表达式</title>
  <indexterm zone="sql-expressions">
   <primary>expression</primary>
   <secondary>syntax</secondary>
  </indexterm>

  <indexterm zone="sql-expressions">
   <primary>value expression</primary>
  </indexterm>

  <indexterm>
   <primary>scalar</primary>
   <see>expression</see>
  </indexterm>

  <!-- 
  <para>
   Value expressions are used in a variety of contexts, such
   as in the target list of the <command>SELECT</command> command, as
   new column values in <command>INSERT</command> or
   <command>UPDATE</command>, or in search conditions in a number of
   commands.  The result of a value expression is sometimes called a
   <firstterm>scalar</firstterm>, to distinguish it from the result of
   a table expression (which is a table).  Value expressions are
   therefore also called <firstterm>scalar expressions</firstterm> (or
   even simply <firstterm>expressions</firstterm>).  The expression
   syntax allows the calculation of values from primitive parts using
   arithmetic, logical, set, and other operations.
  </para> 
  -->
<para>  
值表达式用在各种语法环境中，比如在<command>SELECT</command>命令的目标列表中，
在<command>INSERT</command>或<command>UPDATE</command>中用作新的列值，
或者在许多命令的搜索条件中使用。我们有时候把值表达式的结果叫做<firstterm>标量</firstterm>，
以便与一个表表达式的结果相区别(是一个表)。因此值表达式也叫做
<firstterm>标量表达式</firstterm>(或简称<firstterm>表达式</firstterm>)。
表达式语法允许对来自基本部分的数值进行算术、逻辑、集合、和其它运算。  
</para> 
  <para>
   <!-- 
   A value expression is one of the following: 
   -->
值表达式是下列内容之一：
   <itemizedlist>
    <listitem>
     <para>
      <!-- 
  A constant or literal value 
  -->
  一个常量或者字面值
     </para>
    </listitem>

    <listitem>
     <para>
      <!-- 
  A column reference 
  -->
  一个字段引用
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A positional parameter reference, in the body of a function definition
      or prepared statement
     </para> 
 -->
 <para>
     一个位置参数引用(在函数声明体中或预编写的语句中)
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A subscripted expression
     </para> 
 -->
 <para>
      一个下标表达式
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A field selection expression
     </para> 
 -->
 <para> 
      一个字段选择表达式
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      An operator invocation
     </para> 
 -->
 <para>
      一个操作符调用
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A function call
     </para> 
 -->
 <para>
     一个函数调用
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      An aggregate expression
     </para> 
 -->
 <para>
    一个聚合表达式
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A window function call
     </para> 
 -->
 <para>
      一个窗口函数调用
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A type cast
     </para> 
 -->
 <para>
      一个类型转换
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A collation expression
     </para> 
 -->
 <para>
      一个排序规则表达式
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A scalar subquery
     </para> 
 -->
 <para>
      一个标量子查询
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      An array constructor
     </para> 
 -->
 <para>
      一个数组构造器
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      A row constructor
     </para> 
 -->
 <para>
      一个行构造器
     </para>
    </listitem>

    <listitem>
     <!-- 
 <para>
      Another value expression in parentheses (used to group
      subexpressions and override
      precedence<indexterm><primary>parenthesis</></>)
     </para> 
 -->
<para>
一个在圆括弧里面的值表达式(可用于子表达式分组和覆盖优先级<indexterm><primary>parenthesis</></>)。
</para> 
    </listitem>
   </itemizedlist>
  </para>

  <!-- 
  <para>
   In addition to this list, there are a number of constructs that can
   be classified as an expression but do not follow any general syntax
   rules.  These generally have the semantics of a function or
   operator and are explained in the appropriate location in <xref
   linkend="functions">.  An example is the <literal>IS NULL</literal>
   clause.
  </para> 
  -->
<para>
除了这个列表以外，还有许多构造可以归类为表达式，但是不遵循任何通用的语法规则。
它们通常有函数或操作符的语义，并且在<xref linkend="functions">里合适的位置描述。
一个例子是<literal>IS NULL</literal>子句。
</para>
  <!-- 
  <para>
   We have already discussed constants in <xref
   linkend="sql-syntax-constants">.  The following sections discuss
   the remaining options.
  </para> 
  -->
<para>
我们已经在<xref linkend="sql-syntax-constants">里讨论过常量了。下面的节讨论剩下的选项。  
</para>   
  <sect2 id="sql-expressions-column-refs">
   <!-- 
   <title>Column References</title>
   -->
   <title>字段引用</title>

   <indexterm>
    <primary>column reference</primary>
   </indexterm>

   <para>
    <!-- 
A column can be referenced in the form: 
-->
一个字段可以用下面的形式引用：
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>

   <!-- 
   <para>
    <replaceable>correlation</replaceable> is the name of a
    table (possibly qualified with a schema name), or an alias for a table
    defined by means of a <literal>FROM</literal> clause.
    The correlation name and separating dot can be omitted if the column name
    is unique across all the tables being used in the current query.  (See also <xref linkend="queries">.)
   </para> 
   -->
<para>
<replaceable>correlation</replaceable>是一个表的名字(可能有模式修饰)，
或者是用<literal>FROM</literal>子句这样的方法定义的表的别名。
如果在当前查询所使用的所有表中，该字段名字是唯一的，
那么这个相关名字(correlation)和分隔用的点就可以省略(参见<xref linkend="queries">)。
</para>   
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
   <!-- 
   <title>Positional Parameters</title> 
   -->
<title>位置参数</title>
   <indexterm>
    <primary>parameter</primary>
    <secondary>syntax</secondary>
   </indexterm>

   <indexterm>
    <primary>$</primary>
   </indexterm>

   <para>
    <!-- 
A positional parameter reference is used to indicate a value
    that is supplied externally to an SQL statement.  Parameters are
    used in SQL function definitions and in prepared queries.  Some
    client libraries also support specifying data values separately
    from the SQL command string, in which case parameters are used to
    refer to the out-of-line data values.
    The form of a parameter reference is:
-->
位置参数引用用于标识从外部给 SQL 语句的参数。参数用于 SQL
 函数定义语句和预编写的查询。有些客户端库还支持在 SQL 命令字符串外边声明数据值，
这种情况下参数用于引用 SQL 字符串行外的数据。一个参数的形式如下：
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>

   <para>
    <!-- 
For example, consider the definition of a function,
    <function>dept</function>, as: 
-->
比如下面这个<function>dept</function>函数的定义：
<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

    <!-- 
Here the <literal>$1</literal> references the value of the first
    function argument whenever the function is invoked. 
-->
在函数被调用的时候这里的<literal>$1</literal>将引用第一个参数。
   </para>
  </sect2>

  <sect2 id="sql-expressions-subscripts">
   <!-- 
   <title>Subscripts</title>
   -->
<title>下标</title>
   <indexterm>
    <primary>subscript</primary>
   </indexterm>

   <para>
    <!-- 
If an expression yields a value of an array type, then a specific
    element of the array value can be extracted by writing 
-->
如果一个表达式生成一个数组类型的数值，
那么我们可以通过下面这样的表达式来提取数组中的元素
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
    <!-- 
or multiple adjacent elements (an <quote>array slice</>) can be extracted
    by writing 
-->
或者如果是多个相邻的元素(<quote>数组片断</>)可以用下面的方法抽取
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
    <!-- 
(Here, the brackets <literal>[ ]</literal> are meant to appear literally.)
    Each <replaceable>subscript</replaceable> is itself an expression,
    which must yield an integer value.
-->
(这里的方括号<literal>[ ]</literal>按照字面文本的方式出现。)
每个<replaceable>subscript</replaceable>自己都是一个表达式，它必须生成一个整数值。
   </para>

   <para>
    <!--
In general the array <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be subscripted is just a column reference or positional parameter.
    Also, multiple subscripts can be concatenated when the original array
    is multidimensional.
    For example:
-->
通常，数组<replaceable>expression</replaceable>必须用圆括弧包围，
但如果只是一个字段引用或者一个位置参数，那么圆括弧可以省略。同样，
如果源数组是多维的，那么多个下标可以连接在一起。比如：
<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

    <!-- 
The parentheses in the last example are required.
    See <xref linkend="arrays"> for more about arrays.
-->
最后一个例子里的圆括弧是必须的。参阅<xref linkend="arrays">获取有关数组的更多信息。
   </para>
  </sect2>

  <sect2 id="field-selection">
   <!-- <title>Field Selection</title> -->
<title>字段选择</title>
   <indexterm>
    <primary>field selection</primary>
   </indexterm>

   <para>
<!-- 
    If an expression yields a value of a composite type (row type), then a
    specific field of the row can be extracted by writing 
-->
如果一个表达式生成一个复合类型(行类型)，那么用下面的方法可以抽取一个指定的字段
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>

   <para>
    <!-- 
In general the row <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be selected from is just a table reference or positional parameter.
    For example: 
-->
通常，行<replaceable>expression</replaceable>必须用圆括弧包围，
但是如果要选取的表达式只是一个表引用或者位置参数，可以省略圆括弧。比如:
<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

    <!-- 
(Thus, a qualified column reference is actually just a special case
    of the field selection syntax.)  An important special case is
    extracting a field from a table column that is of a composite type: 
-->
因此，一个全称的字段引用实际上只是一个字段选择语法的特例。
一个重要的特殊情形是提取的表列是一个复合型的字段： 
<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

    <!-- 
The parentheses are required here to show that
    <structfield>compositecol</> is a column name not a table name,
    or that <structname>mytable</> is a table name not a schema name
    in the second case.
-->
在这里，括号是必须的，用来指出<structfield>compositecol</>是列名而不是表名，
<structname>mytable</>是表名而不是模式名。 
   </para>

   <para>
    <!-- 
In a select list (see <xref linkend="queries-select-lists">), you
    can ask for all fields of a composite value by
    writing <literal>.*</literal>: 
-->
在一个选择列表中（查看<xref linkend="queries-select-lists">），
你可以通过使用<literal>.*</literal>来要求所有的组合值字段。
<programlisting>
(compositecol).*
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
   <!-- <title>Operator Invocations</title> -->
<title>操作符调用</title>
   <indexterm>
    <primary>operator</primary>
    <secondary>invocation</secondary>
   </indexterm>

   <para>
    <!-- 
There are three possible syntaxes for an operator invocation:
-->
操作符调用有三种语法：
<!--  
    <simplelist>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> (binary infix operator)</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> (unary prefix operator)</member>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> (unary postfix operator)</member>
    </simplelist>
where the <replaceable>operator</replaceable> token follows the syntax
    rules of <xref linkend="sql-syntax-operators">, or is one of the
    key words <token>AND</token>, <token>OR</token>, and
    <token>NOT</token>, or is a qualified operator name in the form:
-->
<simplelist>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> (双目中缀操作符)</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> (单目前缀操作符)</member>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> (单目后缀操作符)</member>
    </simplelist>
这里的<replaceable>operator</replaceable>记号遵循<xref linkend="sql-syntax-operators">的语法规则，
或者是记号<token>AND</token>，<token>OR</token>，<token>NOT</token>之一。
或者是一个被修饰的操作符名：
<synopsis>
<literal>OPERATOR(</><replaceable>schema</><literal>.</><replaceable>operatorname</><literal>)</>
</synopsis>
    <!-- 
Which particular operators exist and whether
    they are unary or binary depends on what operators have been
    defined by the system or the user.  <xref linkend="functions">
    describes the built-in operators. 
-->
具体存在哪个操作符以及它们是单目还是双目取决于系统或用户定义了什么操作符。
<xref linkend="functions">描述了内置的操作符。
   </para>
  </sect2>

  <sect2 id="sql-expressions-function-calls">
   <!-- <title>Function Calls</title> -->
<title>函数调用</title>
   <indexterm>
    <primary>function</primary>
    <secondary>invocation</secondary>
   </indexterm>

   <para>
    <!-- 
The syntax for a function call is the name of a function
    (possibly qualified with a schema name), followed by its argument list
    enclosed in parentheses: 
-->
函数调用的语法是合法函数名(可能有模式名修饰)，后面跟着包含参数列表的圆括弧：
<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>

   <para>
    <!-- 
For example, the following computes the square root of 2: 
-->
比如，下面的代码计算 2 的平方根：
<programlisting>
sqrt(2)
</programlisting>
   </para>

   
    <!--
<para>
The list of built-in functions is in <xref linkend="functions">.
    Other functions can be added by the user. 
</para>
-->
<para>
内置函数的列表在<xref linkend="functions">里。其它函数可由用户添加。
</para>

   <!-- 
   <para>
    The arguments can optionally have names attached.
    See <xref linkend="sql-syntax-calling-funcs"> for details.
   </para> 
   -->
<para>
可选的可附加名字的参数，详细请参阅<xref linkend="sql-syntax-calling-funcs">。 
</para> 
   <note>
    <!-- 
<para>
     A function that takes a single argument of composite type can
     optionally be called using field-selection syntax, and conversely
     field selection can be written in functional style.  That is, the
     notations <literal>col(table)</> and <literal>table.col</> are
     interchangeable.  This behavior is not SQL-standard but is provided
     in <productname>PostgreSQL</> because it allows use of functions to
     emulate <quote>computed fields</>.  For more information see
     <xref linkend="xfunc-sql-composite-functions">.
    </para> 
-->
<para>
一个接受一个复合类型参数的函数，可以使用字段选择语法调用，相反的，
字段选择可以用函数的风格写出来。也就是说，符号<literal>col(table)</> 
和 <literal>table.col</>是可以互换的。这个行为不是SQL标准，但是由
<productname>PostgreSQL</>提供，因为它允许函数使用仿真<quote>计算域</>。
获取更多信息，请参阅<xref linkend="xfunc-sql-composite-functions">。
</para>
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
   <!-- 
   <title>Aggregate Expressions</title> 
   -->
<title>聚合表达式</title>
   <indexterm zone="syntax-aggregates">
    <primary>aggregate function</primary>
    <secondary>invocation</secondary>
   </indexterm>

   <para>
    <!-- 
An <firstterm>aggregate expression</firstterm> represents the
    application of an aggregate function across the rows selected by a
    query.  An aggregate function reduces multiple inputs to a single
    output value, such as the sum or average of the inputs.  The
    syntax of an aggregate expression is one of the following:
-->
一个<firstterm>聚合表达式</firstterm>代表一个聚合函数对查询选出的行的处理。
一个聚合函数把多个输入缩减为一个输出值，比如给输入求和或求平均。
一个聚合表达式的语法是下列之一：
<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] )
<replaceable>aggregate_name</replaceable> ( * )
</synopsis>

   <!-- 
   where <replaceable>aggregate_name</replaceable> is a previously
    defined aggregate (possibly qualified with a schema name),
    <replaceable>expression</replaceable> is
    any value expression that does not itself contain an aggregate
    expression or a window function call, and
    <replaceable>order_by_clause</replaceable> is a optional
    <literal>ORDER BY</> clause as described below.
-->
这里的<replaceable>aggregate_name</replaceable>是前面定义的聚合(可能是带有模式的全称)，
而<replaceable>expression</replaceable>是一个本身不包含聚合表达式或一个窗口函数调用的任意值表达式。
<replaceable>order_by_clause</replaceable>是<literal>ORDER BY</> 子句的一个选项，下面会有描述。
   </para>

   <!-- 
   <para>
    The first form of aggregate expression invokes the aggregate
    once for each input row.
    The second form is the same as the first, since
    <literal>ALL</literal> is the default.
    The third form invokes the aggregate once for each distinct value
    of the expression (or distinct set of values, for multiple expressions)
    found in the input rows.
    The last form invokes the aggregate once for each input row; since no
    particular input value is specified, it is generally only useful
    for the <function>count(*)</function> aggregate function.
   </para> 
   -->
<para>
第一种形式的聚合表达式为每个输入行调用聚合。
第二种形式与第一种等价(因为<literal>ALL</literal>是缺省值)。
第三种形式为每个表达式中不同的值调用聚合（或者为多个表达式不同的值的集合）。
最后一种形式为每个输入行调用一次聚合，因为没有声明特定的输入值，
通常它只用于<function>count(*)</function>聚合函数。   
</para>   
   <!-- 
   <para>
    Most aggregate functions ignore null inputs, so that rows in which
    one or more of the expression(s) yield null are discarded.  This
    can be assumed to be true, unless otherwise specified, for all
    built-in aggregates.
   </para> 
   -->
<para>
大多数的聚合函数忽略了NULL输入，因此在一个或多个表达式中产生NULL的行会被丢弃。
对所有的内置聚合函数而言，这样做是可以的，除非另行说明。 
</para>
   <!-- 
   <para>
    For example, <literal>count(*)</literal> yields the total number
    of input rows; <literal>count(f1)</literal> yields the number of
    input rows in which <literal>f1</literal> is non-null, since
    <function>count</> ignores nulls; and
    <literal>count(distinct f1)</literal> yields the number of
    distinct non-null values of <literal>f1</literal>.
   </para> 
   -->
<para>
比如，<literal>count(*)</literal>生成输入行的总数；<literal>count(f1)</literal>生成
<literal>f1</literal>不为 NULL 的输入行数，因为<function>count</>忽略NULL；
<literal>count(distinct f1)</literal>生成<literal>f1</literal>唯一且非 NULL 的行数。   
</para>    
   <para>
    <!-- 
Ordinarily, the input rows are fed to the aggregate function in an
    unspecified order.  In many cases this does not matter; for example,
    <function>min</> produces the same result no matter what order it
    receives the inputs in.  However, some aggregate functions
    (such as <function>array_agg</> and <function>string_agg</>) produce
    results that depend on the ordering of the input rows.  When using
    such an aggregate, the optional <replaceable>order_by_clause</> can be
    used to specify the desired ordering.  The <replaceable>order_by_clause</>
    has the same syntax as for a query-level <literal>ORDER BY</> clause, as
    described in <xref linkend="queries-order">, except that its expressions
    are always just expressions and cannot be output-column names or numbers.
    For example: 
-->
一般情况下，输入行会以非特定顺序放入到聚合函数中。在许多情况下，这样做是没有影响的；
如，无论以什么顺序输入，<function>min</>输出相同的结果。然而，
一些聚合函数（如<function>array_agg</> 和 <function>string_agg</>）并非如此。
当使用这种聚合函数时，可以用<replaceable>order_by_clause</>选项指定输入的顺序。
除了它的表达式仅仅只是表达式，并且不能输出列名或列数之外，<replaceable>order_by_clause</>
与<literal>ORDER BY</>查询子句有相同的语法结构，在<xref linkend="queries-order">中有描述，如： 
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>

   <para>
<!-- 
    When dealing with multiple-argument aggregate functions, note that the
    <literal>ORDER BY</> clause goes after all the aggregate arguments.
    For example, write this: 
-->
在处理多参数聚合函数时需要注意，<literal>ORDER BY</>子句要在所有的聚合函数参数之后，如这样写： 

<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
   <!--  not this: -->
   而不是：
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect
</programlisting>
<!--
     The latter is syntactically valid, but it represents a call of a
    single-argument aggregate function with two <literal>ORDER BY</> keys
    (the second one being rather useless since it's a constant). 
-->
后者在语法上是有效的，但它表示的是，
有两个<literal>ORDER BY</>关键字的单参数的聚合函数的调用（第二个是无用的，
因为它是一个常量）。 
   </para>

   <!-- 
   <para>
    If <literal>DISTINCT</> is specified in addition to an
    <replaceable>order_by_clause</>, then all the <literal>ORDER BY</>
    expressions must match regular arguments of the aggregate; that is,
    you cannot sort on an expression that is not included in the
    <literal>DISTINCT</> list.
   </para> 
   -->
<para>
如果<replaceable>order_by_clause</>中声明了<literal>DISTINCT</>，
那么所有的<literal>ORDER BY</>表达式必须匹配规则的聚合参数，也就是说，
不能对没有包含在<literal>DISTINCT</>列表中的表达式进行排序。
</para>
   <note>
<!-- 
    <para>
     The ability to specify both <literal>DISTINCT</> and <literal>ORDER BY</>
     in an aggregate function is a <productname>PostgreSQL</> extension.
    </para>
-->
<para>
同时在一个聚合函数中声明<literal>DISTINCT</>和<literal>ORDER BY</>是<productname>PostgreSQL</>的一个扩展。 
</para>
   </note>

<!-- 
   <para>
    The predefined aggregate functions are described in <xref
    linkend="functions-aggregate">.  Other aggregate functions can be added
    by the user.
   </para> 
-->
<para>
预定义的聚合函数在<xref linkend="functions-aggregate">里描述。其它聚合函数可以由用户增加。
</para>
   <!-- 
   <para>
    An aggregate expression can only appear in the result list or
    <literal>HAVING</> clause of a <command>SELECT</> command.
    It is forbidden in other clauses, such as <literal>WHERE</>,
    because those clauses are logically evaluated before the results
    of aggregates are formed.
   </para> 
   -->
<para>
一个聚合表达式只能在<command>SELECT</>命令的结果列表或者<literal>HAVING</>子句里出现。
禁止在其它子句里出现(比如<literal>WHERE</>子句)，因为这些子句逻辑上在生成聚合结果之前计算。
</para>
   <!-- 
   <para>
    When an aggregate expression appears in a subquery (see
    <xref linkend="sql-syntax-scalar-subqueries"> and
    <xref linkend="functions-subquery">), the aggregate is normally
    evaluated over the rows of the subquery.  But an exception occurs
    if the aggregate's arguments contain only outer-level variables:
    the aggregate then belongs to the nearest such outer level, and is
    evaluated over the rows of that query.  The aggregate expression
    as a whole is then an outer reference for the subquery it appears in,
    and acts as a constant over any one evaluation of that subquery.
    The restriction about
    appearing only in the result list or <literal>HAVING</> clause
    applies with respect to the query level that the aggregate belongs to.
   </para> 
   -->
<para>   
如果一个聚合表达式出现在一个子查询里(参阅<xref linkend="sql-syntax-scalar-subqueries">
和<xref linkend="functions-subquery">)，聚合通常是在子查询中进行计算。
但是如果聚合的参数只包含外层查询的变量则例外：这个聚合会属于离他最近的外层查询，
并且在该查询上进行计算。该聚合表达式整体上属于它出现的子查询对外层查询的引用，
其作用相当于子查询每一次计算中的一个常量。前述限制(聚合表达式只能出现在结果列或者
<literal>HAVING</>子句中)只适用于聚合所属的查询层。
</para>   
  </sect2>

  <sect2 id="syntax-window-functions">
   <!-- 
   <title>Window Function Calls</title> 
   -->
<title>窗口调用函数</title>
   <indexterm zone="syntax-window-functions">
    <primary>window function</primary>
    <secondary>invocation</secondary>
   </indexterm>

   <indexterm zone="syntax-window-functions">
    <primary>OVER clause</primary>
   </indexterm>

   <para>
<!-- 
    A <firstterm>window function call</firstterm> represents the application
    of an aggregate-like function over some portion of the rows selected
    by a query.  Unlike regular aggregate function calls, this is not tied
    to grouping of the selected rows into a single output row &mdash; each
    row remains separate in the query output.  However the window function
    is able to scan all the rows that would be part of the current row's
    group according to the grouping specification (<literal>PARTITION BY</>
    list) of the window function call.
    The syntax of a window function call is one of the following: 
-->
通过查询筛选出的行的某些部分，<firstterm>窗口调用函数</firstterm>实现了类似于聚合函数的功能。
不同的是，窗口调用函数不需要将查询结果打包成一行输出&mdash;在查询输出中，每一行都是分开的。
然而，窗口调用函数可以扫描所有的行，根据窗口调用函数的分组规范(<literal>PARTITION BY</>列)，
这些行可能会是当前行所在组的一部分。一个窗口调用函数的语法是下列之一：
<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) OVER <replaceable>window_name</replaceable>
</synopsis>
<!-- 
    where <replaceable class="parameter">window_definition</replaceable>
    has the syntax 
-->
这里的<replaceable class="parameter">window_definition</replaceable>具有如下语法：
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
<!-- 
    and the optional <replaceable class="parameter">frame_clause</replaceable>
    can be one of 
-->
选项<replaceable class="parameter">frame_clause</replaceable>可以是： 
<synopsis>
[ RANGE | ROWS ] <replaceable>frame_start</>
[ RANGE | ROWS ] BETWEEN <replaceable>frame_start</> AND <replaceable>frame_end</>
</synopsis>
<!-- 
    where <replaceable>frame_start</> and <replaceable>frame_end</> can be
    one of 
-->
<replaceable>frame_start</> 和 <replaceable>frame_end</>可以是： 
<synopsis>
UNBOUNDED PRECEDING
<replaceable>value</replaceable> PRECEDING
CURRENT ROW
<replaceable>value</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
   </para>

<!-- 
   <para>
    Here, <replaceable>expression</replaceable> represents any value
    expression that does not itself contain window function calls.
   </para> 
-->
<para>
在这里，<replaceable>expression</replaceable> 表示的是任何自己不含窗口调用函数的值表达式。
</para>

<!-- 
   <para>
    <replaceable>window_name</replaceable> is a reference to a named window
    specification defined in the query's <literal>WINDOW</literal> clause.
    Named window specifications are usually referenced with just
    <literal>OVER</> <replaceable>window_name</replaceable>, but it is
    also possible to write a window name inside the parentheses and then
    optionally supply an ordering clause and/or frame clause (the referenced
    window must lack these clauses, if they are supplied here).
    This latter syntax follows the same rules as modifying an existing
    window name within the <literal>WINDOW</literal> clause; see the
    <xref linkend="sql-select"> reference
    page for details.
   </para> 
-->
<para>
<replaceable>window_name</replaceable>引用的是查询语句中<literal>WINDOW</literal>
子句定义的命名窗口规范。命名窗口规范通常只是用<literal>OVER</> <replaceable>window_name</replaceable>
来引用，但它也可以在括号里写一个窗口名，并且可以有选择的使用排序和/或框架(frame）子句
（如果应用这些子句的话，那么被引用的窗口必须不能有这些子句）。
后者语法遵循相同的规则（修改<literal>WINDOW</literal>子句中已有的窗口名）。
参阅<xref linkend="sql-select">查看更多资料。 
</para>
<!-- 
   <para>
    The <literal>PARTITION BY</> option groups the rows of the query into
    <firstterm>partitions</>, which are processed separately by the window
    function.  <literal>PARTITION BY</> works similarly to a query-level
    <literal>GROUP BY</> clause, except that its expressions are always just
    expressions and cannot be output-column names or numbers.
    Without <literal>PARTITION BY</>, all rows produced by the query are
    treated as a single partition.
    The <literal>ORDER BY</> option determines the order in which the rows
    of a partition are processed by the window function.  It works similarly
    to a query-level <literal>ORDER BY</> clause, but likewise cannot use
    output-column names or numbers.  Without <literal>ORDER BY</>, rows are
    processed in an unspecified order.
   </para>
-->
<para>
<literal>PARTITION BY</>选项将查询的行分为一组进入<firstterm>partitions</>，
这些行在窗口函数中单独处理。<literal>PARTITION BY</>和查询级别<literal>GROUP BY</>
子句做相似的工作，除了它的表达式只能作为表达式不能作为输出列的名字或数。
没有<literal>PARTITION BY</>，所有由查询产生的行被视为一个单独的分区。<literal>ORDER BY</>
选项决定分区中的行被窗口函数处理的顺序。它和查询级别<literal>ORDER BY</>子句做相似的工作，
但是同样的它不能作为输出列的名字或数。没有<literal>ORDER BY</>，行以一个不被预知的顺序处理。
</para>

<!-- 
   <para>
    The <replaceable class="parameter">frame_clause</replaceable> specifies
    the set of rows constituting the <firstterm>window frame</>, which is a
    subset of the current partition, for those window functions that act on
    the frame instead of the whole partition.  The frame can be specified in
    either <literal>RANGE</> or <literal>ROWS</> mode; in either case, it
    runs from the <replaceable>frame_start</> to the
    <replaceable>frame_end</>.  If <replaceable>frame_end</> is omitted,
    it defaults to <literal>CURRENT ROW</>.
   </para> 
-->
<para>
对这些窗口函数（在这个框架而不是整个分区上的），
<replaceable class="parameter">frame_clause</replaceable>指定构成<firstterm>window frame</>的行，
他们是当前分区的一个子集。框架可以用<literal>RANGE</> 或 <literal>ROWS</>模式声明；不管哪种情况，
它的变化范围是从<replaceable>frame_start</>到<replaceable>frame_end</>。如果省略了<replaceable>frame_end</>
默认为<literal>CURRENT ROW</>。
</para>
<!-- 
   <para>
    A <replaceable>frame_start</> of <literal>UNBOUNDED PRECEDING</> means
    that the frame starts with the first row of the partition, and similarly
    a <replaceable>frame_end</> of <literal>UNBOUNDED FOLLOWING</> means
    that the frame ends with the last row of the partition.
   </para> 
-->
<para>
一个<replaceable>frame_start</>的<literal>UNBOUNDED PRECEDING</>意味着框架从分区中的第一行开始，
相似的，一个<replaceable>frame_end</>的<literal>UNBOUNDED FOLLOWING</>意味着框架从分区中的最后一行结束。
</para>
<!-- 
   <para>
    In <literal>RANGE</> mode, a <replaceable>frame_start</> of
    <literal>CURRENT ROW</> means the frame starts with the current row's
    first <firstterm>peer</> row (a row that <literal>ORDER BY</> considers
    equivalent to the current row), while a <replaceable>frame_end</> of
    <literal>CURRENT ROW</> means the frame ends with the last equivalent
    peer.  In <literal>ROWS</> mode, <literal>CURRENT ROW</> simply means
    the current row.
   </para> 
-->
<para>
在<literal>RANGE</>模式中，<replaceable>frame_start</>的<literal>CURRENT ROW</>
意味着框架从当前行的第一个<firstterm>peer</>行开始（<literal>ORDER BY</>
认为等于当前行的行），而<replaceable>frame_end</>的<literal>CURRENT ROW</>
意味着框架从最后一个同等的行结束。在<literal>ROWS</>模式中， <literal>CURRENT ROW</>
简单的意味着当前行。
</para>
<!-- 
   <para>
    The <replaceable>value</> <literal>PRECEDING</> and
    <replaceable>value</> <literal>FOLLOWING</> cases are currently only
    allowed in <literal>ROWS</> mode.  They indicate that the frame starts
    or ends the specified number of rows before or after the current row.
    <replaceable>value</replaceable> must be an integer expression not
    containing any variables, aggregate functions, or window functions.
    The value must not be null or negative; but it can be zero, which
    just selects the current row.
   </para> 
-->
<para>
<replaceable>value</> <literal>PRECEDING</>和<replaceable>value</> <literal>FOLLOWING</>
当前只允许<literal>ROWS</>模式。这也就意味着，框架从当前行之前或之后指定的行数启动或结束。
<replaceable>value</replaceable>必须是整型表达式，而不能包含变量，聚合函数，或者窗口函数。
该值不能为空或负，但可以是零，表示只选择当前行本身。    
</para>   
<!-- 
   <para>
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</>.  With <literal>ORDER BY</>, this sets the frame to be
    all rows from the partition start up through the current row's last
    peer.  Without <literal>ORDER BY</>, all rows of the partition are
    included in the window frame, since all rows become peers of the current
    row.
   </para> 
-->
<para>
默认的框架选项是<literal>RANGE UNBOUNDED PRECEDING</>，该选项与
<literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</>相同。有<literal>ORDER BY</>，
它设置框架从分区的开始一直到与当前行相同的最后一行。没有<literal>ORDER BY</>，
那么就是当前分区的所有行都包含在框架中，因为所有行都会成为当前行的相同行。
</para>
<!-- 
   <para>
    Restrictions are that
    <replaceable>frame_start</> cannot be <literal>UNBOUNDED FOLLOWING</>,
    <replaceable>frame_end</> cannot be <literal>UNBOUNDED PRECEDING</>,
    and the <replaceable>frame_end</> choice cannot appear earlier in the
    above list than the <replaceable>frame_start</> choice &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</>
    PRECEDING</literal> is not allowed.
   </para>
-->
<para>
限制条件是<replaceable>frame_start</>不能为<literal>UNBOUNDED FOLLOWING</>，
<replaceable>frame_end</>不能为<literal>UNBOUNDED PRECEDING</>，并且<replaceable>frame_end</>
选项不能在上面的列表中出现的比<replaceable>frame_start</>选项早&mdash;例如
<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</> PRECEDING</literal>是不被允许的。
</para>
<!-- 
   <para>
    The built-in window functions are described in <xref
    linkend="functions-window-table">.  Other window functions can be added by
    the user.  Also, any built-in or user-defined aggregate function can be
    used as a window function.
   </para> 
-->
<para>
内置窗口函数在<xref linkend="functions-window-table">中有描述。其他窗口函数，
用户可以自己添加。同样，任意内置或用户自定义聚合函数可以同窗口函数一样使用。
</para>
<!-- 
   <para>
    The syntaxes using <literal>*</> are used for calling parameter-less
    aggregate functions as window functions, for example
    <literal>count(*) OVER (PARTITION BY x ORDER BY y)</>.
    The asterisk (<literal>*</>) is customarily not used for non-aggregate window functions.
    Aggregate window functions, unlike normal aggregate functions, do not
    allow <literal>DISTINCT</> or <literal>ORDER BY</> to be used within the
    function argument list.
   </para> 
-->
<para>
使用<literal>*</>的语法可以用来调用无参数的聚合函数为窗口函数，如
<literal>count(*) OVER (PARTITION BY x ORDER BY y)</>。星号(<literal>*</>)
通常不用于非聚合的窗口函数。与通常的聚合函数不同，聚合窗口函数不允许在函数参数列中使用
<literal>DISTINCT</>或<literal>ORDER BY</>。
</para>
<!-- 
   <para>
    Window function calls are permitted only in the <literal>SELECT</literal>
    list and the <literal>ORDER BY</> clause of the query.
   </para> 
-->
<para>
窗口调用函数只能在<literal>SELECT</literal>列，或者查询的<literal>ORDER BY</>子句中使用。 
</para>
   <para>
<!-- 
    More information about window functions can be found in 
-->
更多关于窗口函数的信息可以参考：
    <xref linkend="tutorial-window">,
    <xref linkend="functions-window">,
    <xref linkend="queries-window">.
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
<!-- 
   <title>Type Casts</title> 
-->
<title>类型转换</title>
   <indexterm>
    <primary>data type</primary>
    <secondary>type cast</secondary>
   </indexterm>

   <indexterm>
    <primary>type cast</primary>
   </indexterm>

   <indexterm>
    <primary>::</primary>
   </indexterm>

   <para>
    <!-- 
A type cast specifies a conversion from one data type to another.
    <productname>PostgreSQL</productname> accepts two equivalent syntaxes
    for type casts: 
-->
 
一个类型转换声明一个从一种数据类型到另外一种数据类型的转换。
<productname>PostgreSQL</productname>接受两种等效的类型转换语法：

<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
 <!-- 
 The <literal>CAST</> syntax conforms to SQL; the syntax with
    <literal>::</literal> is historical <productname>PostgreSQL</productname>
    usage. 
-->
<literal>CAST</>语法遵循 SQL 标准；<literal>::</literal>语法是<productname>PostgreSQL</productname>历史用法。
   </para>

<!-- 
   <para>
    When a cast is applied to a value expression of a known type, it
    represents a run-time type conversion.  The cast will succeed only
    if a suitable type conversion operation has been defined.  Notice that this
    is subtly different from the use of casts with constants, as shown in
    <xref linkend="sql-syntax-constants-generic">.  A cast applied to an
    unadorned string literal represents the initial assignment of a type
    to a literal constant value, and so it will succeed for any type
    (if the contents of the string literal are acceptable input syntax for the
    data type).
   </para> 
-->
<para>
如果对一个已知类型的值表达式应用转换，它代表一个运行时类型转换。
只有在已经定义了合适的类型转换操作的情况下，该转换才能成功。
请注意这一点和用于常量的转换略有区别(如<xref linkend="sql-syntax-constants-generic">所示)。
一个应用于字符串文本的转换表示给该字符串文本的常数值赋予一个初始类型，
因此它对于任何类型都会成功(如果字符串文本的内容符合该数据类型的输入语法)。
</para>
<!-- 
   <para>
    An explicit type cast can usually be omitted if there is no ambiguity as
    to the type that a value expression must produce (for example, when it is
    assigned to a table column); the system will automatically apply a
    type cast in such cases.  However, automatic casting is only done for
    casts that are marked <quote>OK to apply implicitly</>
    in the system catalogs.  Other casts must be invoked with
    explicit casting syntax.  This restriction is intended to prevent
    surprising conversions from being applied silently.
   </para> 
-->
<para>
如果一个值表达式的值对某类型而言不存在混淆的情况，那么我们可以省略明确的类型转换(比如，
在给一个表字段赋值的时候)，而由系统自动执行类型转换。不过，
自动转换只适用于那些系统表中标记着<quote>OK to apply implicitly</>的转换函数。
其它转换函数必须用明确的转换语法调用。这些限制是为了避免一些怪异的转换被自动的应用。
</para>
   <para>
    <!-- 
It is also possible to specify a type cast using a function-like
    syntax: 
-->
我们也可以用函数风格的语法声明一个类型转换：
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
<!-- 
    However, this only works for types whose names are also valid as
    function names.  For example, <literal>double precision</literal>
    cannot be used this way, but the equivalent <literal>float8</literal>
    can.  Also, the names <literal>interval</>, <literal>time</>, and
    <literal>timestamp</> can only be used in this fashion if they are
    double-quoted, because of syntactic conflicts.  Therefore, the use of
    the function-like cast syntax leads to inconsistencies and should
    probably be avoided. 
-->
不过，这个方法只能用于那些类型名同时也是有效函数名的类型。比如，
<literal>double precision</literal>就不能这么用，但是等效的<literal>float8</literal>
可以。同样，<literal>interval</>，<literal>time</>和<literal>timestamp</>
如果加了双引号也只能这么用，因为存在语法冲突。因此，函数风格的类型转换会导致不一致，
所以应该避免这么使用。
   </para>

   <note>
<!-- 
    <para>
     The function-like syntax is in fact just a function call.  When
     one of the two standard cast syntaxes is used to do a run-time
     conversion, it will internally invoke a registered function to
     perform the conversion.  By convention, these conversion functions
     have the same name as their output type, and thus the <quote>function-like
     syntax</> is nothing more than a direct invocation of the underlying
     conversion function.  Obviously, this is not something that a portable
     application should rely on.  For further details see
     <xref linkend="sql-createcast">.
    </para> 
-->
<para>
函数风格语法实际上就是一个函数调用。如果使用两种标准转换语法做运行时转换，
那么它将在内部调用一个已注册的函数执行转换。通常，这种转换函数和它们的输出类型同名，
因此<quote>函数风格语法</>只不过是直接调用底层转换函数。
但是可以移植的程序不能依赖这一点。详情请参阅<xref linkend="sql-createcast">。
</para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
   <!-- <title>Collation Expressions</title> -->
<title>排序规则表达式</title>
   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>

   <para>
<!-- 
    The <literal>COLLATE</literal> clause overrides the collation of
    an expression.  It is appended to the expression it applies to:
-->
<literal>COLLATE</literal>子句重写了表达式的排序规则。它附加到要应用的表达式上：
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
<!-- 
    where <replaceable>collation</replaceable> is a possibly
    schema-qualified identifier.  The <literal>COLLATE</literal>
    clause binds tighter than operators; parentheses can be used when
    necessary. 
-->
这里的<replaceable>collation</replaceable>是一个可能的模式限定标识符。
<literal>COLLATE</literal>子句绑定得比操作符更紧密；需要时可以用括号。
   </para>

<!-- 
   <para>
    If no collation is explicitly specified, the database system
    either derives a collation from the columns involved in the
    expression, or it defaults to the default collation of the
    database if no column is involved in the expression.
   </para> 
-->
<para>
如果没有明确声明排序规则，数据库系统要么从表达式中的列获取一个排序规则，
要么如果表达式中没有包含列，使用数据库的默认排序规则。
</para>
   <para>
    <!-- 
The two common uses of the <literal>COLLATE</literal> clause are
    overriding the sort order in an <literal>ORDER BY</> clause, for
    example: 
-->
<literal>COLLATE</literal>子句的两个常见的使用是重写<literal>ORDER BY</>子句里的排序次序，
例如：
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
    <!-- 
and overriding the collation of a function or operator call that
    has locale-sensitive results, for example: 
-->
和重写执行结果区域敏感的函数或运算符调用的排序规则，例如：
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
<!-- 
    Note that in the latter case the <literal>COLLATE</> clause is
    attached to an input argument of the operator we wish to affect.
    It doesn't matter which argument of the operator or function call the
    <literal>COLLATE</> clause is attached to, because the collation that is
    applied by the operator or function is derived by considering all
    arguments, and an explicit <literal>COLLATE</> clause will override the
    collations of all other arguments.  (Attaching non-matching
    <literal>COLLATE</> clauses to more than one argument, however, is an
    error.  For more details see <xref linkend="collation">.)
    Thus, this gives the same result as the previous example: 
-->
请注意，在后面一种情况下，<literal>COLLATE</>子句附加到我们希望作用的运算符的输入参数。
<literal>COLLATE</>子句附加到运算符或者调用函数的哪个参数不重要，
因为运算符或者函数的排序规则是考虑所有参数得到的，并且一个明确的<literal>COLLATE</>
子句将重写所有其他参数的排序规则。（附加不匹配的<literal>COLLATE</>子句到多个参数，
是一个错误。更多详细信息请参阅<xref linkend="collation">。）因此，
下面的例子给出前一个例子相同的结果：
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
   <!-- 
   But this is an error: 
   -->
但是这样做是错误的：
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
    <!-- 
because it attempts to apply a collation to the result of the
    <literal>&gt;</> operator, which is of the non-collatable data type
    <type>boolean</>. 
-->
因为它尝试应用一个排序规则到<literal>&gt;</>运算符的结果，而这个结果是非排序规则类型<type>boolean</>。
   </para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
   <!-- 
   <title>Scalar Subqueries</title>
   -->
<title>标量子查询</title>
   <indexterm>
    <primary>subquery</primary>
   </indexterm>

<!-- 
   <para>
    A scalar subquery is an ordinary
    <command>SELECT</command> query in parentheses that returns exactly one
    row with one column.  (See <xref linkend="queries"> for information about writing queries.)
    The <command>SELECT</command> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <xref linkend="functions-subquery"> for other expressions involving subqueries.
   </para> 
-->
<para>
一个标量子查询是一个放在圆括弧里只返回一行一列的普通<command>SELECT</command>
查询(参阅<xref linkend="queries">获取有关书写查询的信息)。该<command>SELECT</command>
将被执行，而其返回值将在周围的值表达式中使用。
把一个返回超过一行或者超过一列的查询用做标量查询是错误的。
（不过，在一个特定的表达式中，子查询不返回行则不算错误；标量结果被认为是 NULL)。
子查询可以引用外围查询的变量，这些变量在每次子查询中当做常量使用。
参见<xref linkend="functions-subquery">以获取其它包含子查询的表达式。
</para>
   <para>
   <!-- 
   For example, the following finds the largest city population in each
    state: 
-->
比如，下面的查询找出每个州中的最大人口数量的城市：
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
   <!-- <title>Array Constructors</title> -->
<title>数组构造器</title>
   <indexterm>
    <primary>array</primary>
    <secondary>constructor</secondary>
   </indexterm>

   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

   <para>
<!-- 
    An array constructor is an expression that builds an
    array value using values for its member elements.  A simple array
    constructor
    consists of the key word <literal>ARRAY</literal>, a left square bracket
    <literal>[</>, a list of expressions (separated by commas) for the
    array element values, and finally a right square bracket <literal>]</>.
    For example: 
-->
一个数组构造器是一个表达式，它从自身成员元素上构造一个数组值。
一个简单的数组构造器由关键字<literal>ARRAY</literal>、一个左方括弧
<literal>[</>、一个或多个表示数组元素值的表达式(用逗号分隔)、一个右方括弧<literal>]</>
组成。比如：
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</programlisting>
<!-- 
    By default,
    the array element type is the common type of the member expressions,
    determined using the same rules as for <literal>UNION</> or
    <literal>CASE</> constructs (see <xref linkend="typeconv-union-case">).
    You can override this by explicitly casting the array constructor to the
    desired type, for example: 
-->
默认的，数组元素类型是成员表达式的公共类型，使用和<literal>UNION</>或
<literal>CASE</>构造一样的规则决定(参阅<xref linkend="typeconv-union-case">)。
你可以通过明确地转换数组构造器为想要的类型来重写这个规则，例如：
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</programlisting>
<!-- 
    This has the same effect as casting each expression to the array
    element type individually.
    For more on casting, see <xref linkend="sql-syntax-type-casts">. 
-->
这和单独构造每个表达式为数组元素类型有相同的效果。关于构造的更多信息，请参阅<xref linkend="sql-syntax-type-casts">。
   </para>

   <para>
<!-- 
    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the key word <literal>ARRAY</literal> can
    be omitted.  For example, these produce the same result: 
-->
多维数组值可以通过嵌套数组构造器的方法来制作。内层构造器中的<literal>ARRAY</literal>
关键字可以省略。比如，下面的两句生成同样的结果：
<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</programlisting>

<!-- 
    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
    Any cast applied to the outer <literal>ARRAY</> constructor propagates
    automatically to all the inner constructors. 
-->
因为多维数组必须是方形，所以同层的内层构造器必须生成同维的子数组。
任何应用于外层<literal>ARRAY</>构造器的类型转换自动的应用到所有的内层构造器。
  </para>

  <para>
<!-- 
    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<literal>ARRAY</> construct.
    For example: 
-->
多维数组构造器元素可以是任何生成合适数组的东西，而不仅仅是一个子<literal>ARRAY</>构造。比如：
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>

  <para>
<!-- 
   You can construct an empty array, but since it's impossible to have an
   array with no type, you must explicitly cast your empty array to the
   desired type.  For example: 
-->
因为数组必须得有类型，因此在构造一个空数组时，必须明确的将其构造成需要的类型，如：
<programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
</programlisting>
  </para>

  <para>
<!-- 
   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   key word <literal>ARRAY</literal> followed by a parenthesized (not
   bracketed) subquery. For example: 
-->
我们也可以从一个子查询的结果中构造一个数组。此时，
数组构造器是关键字<literal>ARRAY</literal>后跟着一个用圆括弧(不是方括弧)包围的子查询。比如：
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)
</programlisting>
<!-- 
   The subquery must return a single column. The resulting
   one-dimensional array will have an element for each row in the
   subquery result, with an element type matching that of the
   subquery's output column. 
-->
子查询必须只返回一个单独的字段。生成的一维数组将为子查询里每行结果生成一个元素，
元素类型匹配子查询的输出字段。
  </para>

<!-- 
  <para>
   The subscripts of an array value built with <literal>ARRAY</literal>
   always begin with one.  For more information about arrays, see
   <xref linkend="arrays">.
  </para> 
-->
<para>
用<literal>ARRAY</literal>建立的数组下标总是从1开始。
有关数组的更多信息，参阅<xref linkend="arrays">。
</para>
  </sect2>

  <sect2 id="sql-syntax-row-constructors">
   <!-- 
   <title>Row Constructors</title>
   -->
<title>行构造器</title>
   <indexterm>
    <primary>composite type</primary>
    <secondary>constructor</secondary>
   </indexterm>

   <indexterm>
    <primary>row type</primary>
    <secondary>constructor</secondary>
   </indexterm>

   <indexterm>
    <primary>ROW</primary>
   </indexterm>

   <para>
<!-- 
    A row constructor is an expression that builds a row value (also
    called a composite value) using values
    for its member fields.  A row constructor consists of the key word
    <literal>ROW</literal>, a left parenthesis, zero or more
    expressions (separated by commas) for the row field values, and finally
    a right parenthesis.  For example: 
-->
行构造器是一个从提供给它的成员字段数值中构造行值(也叫复合类型值)的表达式。
一个行构造器由关键字<literal>ROW</literal>、一个左圆括弧、零个或多个作为行字段值的表达式(用逗号分隔)、
一个右圆括弧组成。比如：
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
<!-- 
    The key word <literal>ROW</> is optional when there is more than one
    expression in the list. 
-->
如果在列表里有多个表达式，那么关键字<literal>ROW</>是可选的。
   </para>

   <para>
<!-- 
    A row constructor can include the syntax
    <replaceable>rowvalue</replaceable><literal>.*</literal>,
    which will be expanded to a list of the elements of the row value,
    just as occurs when the <literal>.*</> syntax is used at the top level
    of a <command>SELECT</> list.  For example, if table <literal>t</> has
    columns <literal>f1</> and <literal>f2</>, these are the same: 
-->
行构造器可以包含<replaceable>rowvalue</replaceable><literal>.*</literal>语法，
它将被扩展为行值元素的列表，就像将<literal>.*</>语法用于一个<command>SELECT</>
列表顶层一样。例如，如果表<literal>t</>有<literal>f1</>和<literal>f2</>两个字段，
那么下面两句是等价的：
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>

   <note>
<!-- 
    <para>
     Before <productname>PostgreSQL</productname> 8.2, the
     <literal>.*</literal> syntax was not expanded, so that writing
     <literal>ROW(t.*, 42)</> created a two-field row whose first field
     was another row value.  The new behavior is usually more useful.
     If you need the old behavior of nested row values, write the inner
     row value without <literal>.*</literal>, for instance
     <literal>ROW(t, 42)</>.
    </para> 
-->
<para>
在<productname>PostgreSQL</productname> 8.2之前，<literal>.*</literal>语法是不会被扩展的，
所以<literal>ROW(t.*, 42)</> 将创建一个两字段的行，其第一个字段是另一行的值。
新的行为通常更有用。如果你需要旧式的嵌套行值的做法，请将内部的行值写成不包含<literal>.*</literal>，
比如<literal>ROW(t, 42)</>。
</para>
   </note>

   <para>
<!-- 
    By default, the value created by a <literal>ROW</> expression is of
    an anonymous record type.  If necessary, it can be cast to a named
    composite type &mdash; either the row type of a table, or a composite type
    created with <command>CREATE TYPE AS</>.  An explicit cast might be needed
    to avoid ambiguity.  For example: 
-->
缺省时，<literal>ROW</>表达式创建的值是一个匿名的记录类型。如果必要，
你可以把它转换成一个命名的复合类型(既可以是一个表的行类型，
也可以是一个用<command>CREATE TYPE AS</>创建的复合类型)。
可能会需要一个明确的转换以避免歧义。比如：
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!-- &#045;- No cast needed since only one getf1() exists -->

-- 因为只有一个getf1()存在，所以不需要类型转换
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!-- &#045;- Now we need a cast to indicate which function to call: -->
-- 现在我们需要类型转换以表明调用哪个函数：
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
</programlisting>
  </para>

  <para>
<!-- 
   Row constructors can be used to build composite values to be stored
   in a composite-type table column, or to be passed to a function that
   accepts a composite parameter.  Also,
   it is possible to compare two row values or test a row with
   <literal>IS NULL</> or <literal>IS NOT NULL</>, for example: 
-->
行构造器可以用于制作存储在复合类型字段中的复合类型值，
或者是传递给一个接受复合类型参数的函数。另外，
我们也可以用它比较两个行值或者用<literal>IS NULL</>
或<literal>IS NOT NULL</>测试一个行值，比如：
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -- detect all-null rows
</programlisting>
<!-- 
   For more detail see <xref linkend="functions-comparisons">.
   Row constructors can also be used in connection with subqueries,
   as discussed in <xref linkend="functions-subquery">. 
-->
更多的细节，请参阅<xref linkend="functions-comparisons">。
行构造器还可以用于连接子查询，这些在<xref linkend="functions-subquery">里面有详细讨论。
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
   <!-- <title>Expression Evaluation Rules</title> -->
<title>表达式计算规则</title>
   <indexterm>
    <primary>expression</primary>
    <secondary>order of evaluation</secondary>
   </indexterm>

<!-- 
   <para>
    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
   </para>
-->
<para>
子表达式的计算顺序是未定义的。特别要指出的是，
一个操作符或者函数的输入并不一定是按照从左向右的顺序或者以某种特定的顺序进行计算的。
</para>
   <para>
<!-- 
    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote: 
-->
另外，如果一个表达式的结果可以通过只判断它的一部分就可以得到，
那么其它子表达式就可以完全不计算了。比如，如果我们这么写：
<programlisting>
SELECT true OR somefunc();
</programlisting>
<!-- 
    then <literal>somefunc()</literal> would (probably) not be called
    at all. The same would be the case if one wrote: 
-->
那么<literal>somefunc()</literal>就(可能)根本不会被调用。
即使像下面这样写也是一样：
<programlisting>
SELECT somefunc() OR true;
</programlisting>
<!-- 
    Note that this is not the same as the left-to-right
    <quote>short-circuiting</quote> of Boolean operators that is found
    in some programming languages. 
-->
请注意这和某些编程语言里从左向右<quote>短路</quote>布尔操作符是不一样的。
   </para>

<!-- 
   <para>
    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <literal>WHERE</> and <literal>HAVING</> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<literal>AND</>/<literal>OR</>/<literal>NOT</> combinations) in those clauses can be reorganized
    in any manner allowed by the laws of Boolean algebra.
   </para> 
-->
<para>
因此，拿有副作用的函数作为复杂表达式的一部分是不明智的。
在<literal>WHERE</>和<literal>HAVING</>子句里依赖副作用或者是计算顺序是特别危险的，
因为这些子句都是作为生成一个执行规划的一部分进行了大量的再处理。
在这些子句里的布尔表达式(<literal>AND</>/<literal>OR</>/<literal>NOT</>
的组合)可以用布尔代数运算律允许的任何方式进行识别。
</para>
   <para>
<!-- 
    When it is essential to force evaluation order, a <literal>CASE</>
    construct (see <xref linkend="functions-conditional">) can be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <literal>WHERE</> clause: 
-->
如果需要强制计算顺序，那么可以使用<literal>CASE</>构造(参阅<xref linkend="functions-conditional">)。
比如，下面是一种企图避免在<literal>WHERE</>子句里被零除的不可靠方法：
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
    <!-- But this is safe: -->
但是下面这个是安全的：
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
<!-- 
    A <literal>CASE</> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would be better to sidestep the problem by writing
    <literal>y &gt; 1.5*x</> instead.) 
-->
这种风格的<literal>CASE</>构造会阻止优化，因此应该只在必要的时候才使用。
在这个特殊的例子里，毫无疑问写成 <literal>y &gt; 1.5*x</>更好。
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
  <!-- <title>Calling Functions</title> -->
<title>调用函数</title>
   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>functions</secondary>
   </indexterm>

<!--
    <para>
    <productname>PostgreSQL</productname> allows functions that have named
    parameters to be called using either <firstterm>positional</firstterm> or
    <firstterm>named</firstterm> notation.  Named notation is especially
    useful for functions that have a large number of parameters, since it
    makes the associations between parameters and actual arguments more
    explicit and reliable.
    In positional notation, a function call is written with
    its argument values in the same order as they are defined in the function
    declaration.  In named notation, the arguments are matched to the
    function parameters by name and can be written in any order.
   </para> 
-->
<para>
<productname>PostgreSQL</productname>允许函数有命名参数，可以被<firstterm>位置</firstterm>
或<firstterm>名称</firstterm>表示法调用。名称表示法对有大量参数的函数特别有用，
因为它更加明确和可靠的标记了形参和实参之间的联系。
在位置表示法里，一个函数调用的参数值要用与函数声明相同的顺序来写出。
在名称表示法里，参数是通过名称来与函数参数相匹配的，可以以任意顺序写出。
</para>
<!-- 
   <para>
    In either notation, parameters that have default values given in the
    function declaration need not be written in the call at all.  But this
    is particularly useful in named notation, since any combination of
    parameters can be omitted; while in positional notation parameters can
    only be omitted from right to left.
   </para> 
-->
<para>
不管用那种表示法，在函数声明时给出的有默认值的参数在调用时不必写出。
但是这在名称表示法中是特别有用的，因为参数的任意组合都是可以省略的。
而在位置表示法中，参数只能从右到左省略。
</para>
<!-- 
   <para>
    <productname>PostgreSQL</productname> also supports
    <firstterm>mixed</firstterm> notation, which combines positional and
    named notation.  In this case, positional parameters are written first
    and named parameters appear after them.
   </para> 
-->
<para>
<productname>PostgreSQL</productname>也支持<firstterm>混合</firstterm>表示法，
混合表示法结合了位置和名称表示法。因为这个原因，先写位置参数然后跟着写命名参数。
</para>
   <para>
<!-- 
    The following examples will illustrate the usage of all three
    notations, using the following function definition: 
-->
下面的例子将说明三种表示法的用法，使用下面的函数定义：
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
<!-- 
    Function <function>concat_lower_or_upper</function> has two mandatory
    parameters, <literal>a</literal> and <literal>b</literal>.  Additionally
    there is one optional parameter <literal>uppercase</literal> which defaults
    to <literal>false</literal>.  The <literal>a</literal> and
    <literal>b</literal> inputs will be concatenated, and forced to either
    upper or lower case depending on the <literal>uppercase</literal>
    parameter.  The remaining details of this function
    definition are not important here (see <xref linkend="extend"> for
    more information). 
-->
函数<function>concat_lower_or_upper</function>有两个强制的参数，<literal>a</literal>和<literal>b</literal>。
此外第三个参数是一个可选参数<literal>uppercase</literal>，默认为<literal>false</literal>。
<literal>a</literal>和<literal>b</literal>输入将被串联，并且将根据<literal>uppercase</literal>
参数强制为大写或者小写。这个函数定义的其他详细资料在这并不重要（参阅<xref linkend="extend">
获取更多信息）。
   </para>

   <sect2 id="sql-syntax-calling-funcs-positional">
    <!-- <title>Using Positional Notation</title> -->
<title>使用位置表示法</title>
    <indexterm>
     <primary>function</primary>
     <secondary>positional notation</secondary>
    </indexterm>

    <para>
<!-- 
     Positional notation is the traditional mechanism for passing arguments
     to functions in <productname>PostgreSQL</productname>.  An example is: 
-->
在<productname>PostgreSQL</productname>中，位置表示法是传递参数到函数的传统机制。
一个例子是：
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
<!-- 
     All arguments are specified in order.  The result is upper case since
     <literal>uppercase</literal> is specified as <literal>true</literal>.
     Another example is:
-->
所有的参数都按顺序指定。因为<literal>uppercase</literal>被指定为<literal>true</literal>，
所以结果为大写。另外一个例子是：
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
<!-- 
     Here, the <literal>uppercase</literal> parameter is omitted, so it
     receives its default value of <literal>false</literal>, resulting in
     lower case output.  In positional notation, arguments can be omitted
     from right to left so long as they have defaults. 
-->
这里，省略了参数<literal>uppercase</literal>，所以接受它的默认值<literal>false</literal>，
导致小写的输出。在位置表示法中，参数只要有默认值就可以从右到左省略。
    </para>
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
    <!-- <title>Using Named Notation</title> -->
<title>使用名称表示法</title>
    <indexterm>
     <primary>function</primary>
     <secondary>named notation</secondary>
    </indexterm>

    <para>
<!-- 
     In named notation, each argument's name is specified using
     <literal>:=</literal> to separate it from the argument expression.
     For example: 
-->
在名称表示法中，每个参数名字是使用<literal>:=</literal>声明的，用来将它从参数表达式中独立出来。
例如：
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
<!-- 
     Again, the argument <literal>uppercase</literal> was omitted
     so it is set to <literal>false</literal> implicitly.  One advantage of
     using named notation is that the arguments may be specified in any
     order, for example: 
-->
另外，参数<literal>uppercase</literal>是省略的，所以它被隐式的设置为<literal>false</literal>。
使用名称表示法的好处之一是参数可以用任意顺序声明，例如：
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
   <!-- <title>Using Mixed Notation</title> -->
<title>使用混合表示法</title>
   <indexterm>
    <primary>function</primary>
    <secondary>mixed notation</secondary>
   </indexterm>

   <para>
<!-- 
    The mixed notation combines positional and named notation. However, as
    already mentioned, named arguments cannot precede positional arguments.
    For example: 
-->
混合表示法结合了位置和名称表示法。然而，就像之前提到的，命名参数不可以在位置参数前面。例如：
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
<!-- 
    In the above query, the arguments <literal>a</literal> and
    <literal>b</literal> are specified positionally, while
    <literal>uppercase</> is specified by name.  In this example,
    that adds little except documentation.  With a more complex function
    having numerous parameters that have default values, named or mixed
    notation can save a great deal of writing and reduce chances for error. 
-->
在上面的查询中，参数<literal>a</literal>和<literal>uppercase</>是用位置声明的，而
<literal>uppercase</>是用名称声明的。在这个例子中，添加了文档中没有的一点。
在一个有多个参数有默认值的更复杂的函数中，名称或者混合表示法可以节省很多敲键，
并且可以减少犯错的几率。
   </para>
  </sect2>
 </sect1>

</chapter>
